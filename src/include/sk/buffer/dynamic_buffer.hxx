/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_BUFFER_DYNAMIC_BUFFER_HXX_INCLUDED
#define SK_BUFFER_DYNAMIC_BUFFER_HXX_INCLUDED

#include <cassert>
#include <cstddef>
#include <span>
#include <type_traits>

#include <sk/buffer/buffer.hxx>
#include <sk/check.hxx>
#include <sk/static_range.hxx>

namespace sk {

    /*************************************************************************
     *
     * dynamic_buffer: a buffer which grows and contracts dynamically as
     * required. Growth is managed efficiently so the data is never copied, and
     * there is no upper bound on the size of the buffer (other than available
     * memory).
     *
     * A dynamic buffer consists of a series of fixed_buffers, which are
     * contiguous ranges of objects of a fixed size, organised into a deque. New
     * fixed_buffers will be automatically added and removed as the buffer is
     * used.
     *
     */

    // Calculate how large a buffer extent should be if we want to use
    // a specific number of bytes.

    template <typename Char>
    constexpr auto extent_size_from_bytes(int nbytes)
    {
        return nbytes / sizeof(Char);
    }

    static constexpr auto dynamic_buffer_size(std::size_t n)
    {
        return n + (sizeof(char *) * 3);
    }

    template <typename Char,
              std::size_t extent_bytes = 4096,
              std::size_t max_ranges = 5>
    struct dynamic_buffer {
        using size_type = std::size_t;
        using value_type = Char;
        using const_value_type = std::add_const_t<Char>;

    private:
        static constexpr std::size_t extent_size =
            extent_size_from_bytes<value_type>(extent_bytes);

        struct extent_type {
            extent_type *next = nullptr;
            value_type *read_pointer;
            value_type *write_pointer;

            static constexpr std::size_t bksize =
                // we actually want the size of the next pointer, not *next.
                // NOLINTNEXTLINE(bugprone-sizeof-expression)
                sizeof(next) + sizeof(read_pointer) + sizeof(write_pointer);

            static_assert(extent_size > bksize, "dynamic_buffer is too small");

            static constexpr std::size_t xsize = extent_size - bksize;

            // using a C array for this specific application is fine.
            // NOLINTNEXTLINE(cppcoreguidelines-avoid-c-arrays,hicpp-avoid-c-arrays,modernize-avoid-c-arrays)
            Char data[xsize];

            extent_type() : read_pointer(&data[0]), write_pointer(read_pointer)
            {
            }

            extent_type(extent_type const &) = delete;
            extent_type(extent_type &&) = delete;
            auto operator=(extent_type const &) = delete;
            auto operator=(extent_type &&) = delete;
            ~extent_type() = default;

            constexpr auto readable() -> std::size_t
            {
                return std::distance(read_pointer, write_pointer);
            }

            constexpr auto empty()
            {
                return write_pointer == begin();
            }

            constexpr auto writable() -> std::size_t
            {
                return std::distance(write_pointer, end());
            }

            constexpr auto begin()
            {
                return &data[0];
            }

            constexpr auto end()
            {
                return &data[0] + xsize;
            }

            constexpr auto dead()
            {
                return readable() == 0 && writable() == 0;
            }

            void clear()
            {
                read_pointer = begin();
                write_pointer = begin();
            }
        };

        // static_assert(sizeof(extent_type) == extent_bytes);

        // Head and tail of the extent list.  The tail is not the actual tail
        // of the list, but rather the extent we're currently writing to.
        extent_type *_head = nullptr, *_tail = nullptr;

        // The minimum amount of space to keep available for writing; if the
        // write window is small than this, we will allocate a new extent.
        // This ensures users writing directly into the buffer have sufficient
        // space to write into.
        static constexpr std::size_t minfree = extent_size / 2;

        // Remove the current head (read) extent.
        auto _kill_head() noexcept -> void;

        // Add a new write extent at the end of the buffer.
        auto _make_tail() -> void;

        // Free all extents.
        auto _xfree() noexcept -> void;

    public:
        // Create a new, empty buffer with a single extent.
        dynamic_buffer();
        ~dynamic_buffer();

        // dynamic_buffer is not copyable, but can be moved.
        dynamic_buffer(dynamic_buffer const &) = delete;
        auto operator=(dynamic_buffer const &) -> dynamic_buffer & = delete;
        dynamic_buffer(dynamic_buffer &&) noexcept;
        auto operator=(dynamic_buffer &&) noexcept -> dynamic_buffer &;

        // Write data to the buffer.  All of the data will be written, and the
        // buffer will be expanded to fit the data if necessary.
        auto write(const_value_type *dptr, size_type dsize) -> size_type;

        // Read data from the buffer.  As much data will be read as possible,
        // and the number of objects read will be returned.  If the return value
        // is less than the requested number of objects, the buffer is now
        // empty.
        auto read(value_type *dptr, size_type dsize) -> size_type;

        // Return a list of ranges which represent data in the buffer
        // which can be read.  Writing data to the buffer will not invalidate
        // the ranges.
        //
        // After reading the data, discard() should be called to remove the
        // data from the buffer.
        auto readable_ranges()
            -> static_range<std::span<const_value_type>, max_ranges>;

        // Discard up to n bytes of readable data from the start of the buffer.
        // Returns the number of bytes discarded.
        auto discard(size_type n) -> size_type;

        // Return a list of ranges representing space in the buffer
        // which can be written to.  After writing the data, commit() should be
        // called to mark the space as used.
        auto writable_ranges()
            -> static_range<std::span<value_type>, max_ranges>;

        // Mark n bytes of previously empty space as containing data.
        auto commit(size_type n) -> size_type;

    private:
        // Ensure that at least minfree objects of write space is available.
        auto _ensure_minfree() -> void;
    };

    static_assert(buffer<dynamic_buffer<char>>);

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    dynamic_buffer<Char, extent_size, max_ranges>::dynamic_buffer()
    {
        _tail = _head = new extent_type;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    dynamic_buffer<Char, extent_size, max_ranges>::dynamic_buffer(
        dynamic_buffer &&other) noexcept
        : _head(std::exchange(other._head, nullptr)),
          _tail(std::exchange(other._tail, nullptr))
    {
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::operator=(
        dynamic_buffer &&other) noexcept -> dynamic_buffer &
    {
        _xfree();
        _head = std::exchange(other._head, nullptr);
        _tail = std::exchange(other._tail, nullptr);
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    dynamic_buffer<Char, extent_size, max_ranges>::~dynamic_buffer()
    {
        _xfree();
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::_kill_head() noexcept
        -> void
    {
        sk::detail::check(_head->dead(),
                          "INTERNAL ERROR: dynamic_buffer::_kill_head() trying "
                          "to remove active head");

        sk::detail::check(_head != _tail,
                          "INTERNAL ERROR: dynamic_buffer::_kill_head() trying "
                          "to remove our only head");

        auto old_head = _head;
        old_head->clear();

        _head = _head->next;
        old_head->next = _tail->next;
        _tail->next = old_head;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::_make_tail() -> void
    {
        if (_tail->next) {
            sk::detail::check(_tail->next->empty(),
                              "INTERNAL ERROR: dynamic_buffer::_make_tail: "
                              "next tail not empty");
            _tail = _tail->next;
            return;
        }

        auto *new_tail = new extent_type;
        new_tail->next = _tail->next;
        _tail->next = new_tail;
        _tail = _tail->next;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::_xfree() noexcept
        -> void
    {
        while (_head) {
            auto *p = _head;
            _head = _head->next;
            delete p;
        }

        _head = _tail = nullptr;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::_ensure_minfree()
        -> void
    {
        if (_tail->empty())
            return;

        if (_tail->next) {
            sk::detail::check(
                _tail->next->empty(),
                "INTERNAL ERROR: dynamic_buffer::_ensure_minfree: next tail "
                "not empty");
            return;
        }

        _make_tail();
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::write(
        const_value_type *dptr, size_type dsize) -> size_type
    {
        auto *cptr = dptr;
        auto *cend = cptr + dsize;

        sk::detail::check(cptr <= cend,
                          "dynamic_buffer::write: dsize overflow");

        while (cptr < cend) {
            // Is the tail full?
            if (_tail->writable() == 0)
                _make_tail();

            // Copy as much as we can into the current tail.
            auto wr = std::min(static_cast<size_type>(cend - cptr),
                               _tail->writable());

            sk::detail::check(
                (_tail->write_pointer + wr) <= _tail->end() &&
                    (cptr + wr) <= cend,
                "INTERNAL ERROR: dynamic_buffer: write: overflow");

            _tail->write_pointer =
                std::copy(cptr, cptr + wr, _tail->write_pointer);
            cptr += wr;
        }

        sk::detail::check(static_cast<std::size_t>(cptr - dptr) == dsize,
                          "dynamic_buffer::write(): short write");
        return cptr - dptr;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::read(value_type *dptr,
                                                             size_type dsize)
        -> size_type
    {
        auto *cptr = dptr;
        auto *cend = cptr + dsize;

        sk::detail::check(cptr <= cend, "dynamic_buffer::read: dsize overflow");

        while (cptr < cend) {
            sk::detail::check(
                !_head->dead(),
                "INTERNAL ERROR: dynamic_buffer::read: unexpected dead head");

            if (_head->readable() == 0) {
                break;
            }

            auto rd = std::min(static_cast<size_type>(cend - cptr),
                               _head->readable());

            sk::detail::check((_head->read_pointer + rd) <=
                                      _head->write_pointer &&
                                  (cptr + rd) <= cend,
                              "INTERNAL ERROR: dynamic_buffer: read: overflow");

            std::copy(_head->read_pointer, _head->read_pointer + rd, cptr);
            cptr += rd;
            _head->read_pointer += rd;

            if (_head->dead()) {
                if (_head != _tail)
                    _kill_head();
                else
                    _head->clear();
            }
        }

        return cptr - dptr;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::writable_ranges()
        -> static_range<std::span<Char>, max_ranges>
    {
        static_range<std::span<Char>, max_ranges> ret;

        // Make sure we always return a reasonable amount of writable space.
        _ensure_minfree();

        auto *tptr = _tail;

        sk::detail::check(
            _tail != nullptr,
            "INTERNAL ERROR: dynamic_buffer::writable_ranges: no tail?");

        for (;;) {
            if (ret.size() == ret.capacity())
                break;

            if (!tptr)
                break;

            sk::detail::check(
                tptr->writable() > 0,
                "INTERNAL ERROR: dynamic_buffer::writable_ranges: unexpected "
                "full tail");

            ret.push_back(std::span(tptr->write_pointer, tptr->end()));

            tptr = tptr->next;
        }

        return ret;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::commit(std::size_t n)
        -> size_type
    {
        auto cn = n;

        while (cn > 0) {
            if (_tail->writable() == 0) {
                sk::detail::check(_tail->next != nullptr,
                                  "dynamic_buffer::commit(): no tail");
                _tail = _tail->next;
            }

            auto cancommit = std::min(cn, _tail->writable());
            _tail->write_pointer += cancommit;
            cn -= cancommit;
        }

        sk::detail::check(cn == 0, "dynamic_buffer::commit(): short commit");
        return n - cn;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::readable_ranges()
        -> static_range<std::span<const_value_type>, max_ranges>
    {
        static_range<std::span<const_value_type>, max_ranges> ret;

        auto *hptr = _head;
        while (ret.size() < ret.capacity()) {
            sk::detail::check(
                _head->readable() > 0,
                "INTERNAL ERROR: dynamic_buffer::readable_ranges: unreadable "
                "head");

            ret.push_back(std::span(hptr->read_pointer, hptr->write_pointer));
            hptr = hptr->next;
            if (!hptr)
                break;
        }

        return ret;
    }

    template <typename Char, std::size_t extent_size, std::size_t max_ranges>
    auto dynamic_buffer<Char, extent_size, max_ranges>::discard(size_type n)
        -> size_type
    {
        auto left = n;

        while (left) {
            sk::detail::check(
                _head->readable() > 0,
                "INTERNAL ERROR: dynamic_buffer::discard: unreadable head");

            auto candisc = std::min(left, _head->readable());
            _head->read_pointer += candisc;

            if (_head->dead()) {
                if (_head != _tail)
                    _kill_head();
                else
                    _head->clear();
            }

            left -= candisc;
        }

        return n - left;
    }

} // namespace sk

#endif // SK_BUFFER_DYNAMIC_BUFFER_HXX_INCLUDED
