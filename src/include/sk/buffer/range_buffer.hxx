/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/*
 * Concepts of buffers.
 */

#ifndef SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED
#define SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED

#include <cstddef>
#include <cstring>
#include <ranges>
#include <span>

#include <sk/buffer.hxx>

namespace sk {

    /*************************************************************************
     *
     * range buffer: a buffer that exposes a range of `T` as a writable buffer,
     * or a range of `const T` as a readable buffer.  This can be used to wrap
     * existing ranges, e.g. to write directly into the destination.
     *
     */

    /*************************************************************************
     *
     * readable_range_buffer: a readable_buffer that exposes data from a
     * contiguous range.
     */
    template <std::ranges::contiguous_range Range>
    struct readable_range_buffer {
        using value_type =
            std::remove_const_t<std::ranges::range_value_t<Range>>;
        using const_value_type = std::add_const_t<value_type>;
        using size_type = std::ranges::range_size_t<Range>;

        std::span<const_value_type> read_window;

        explicit readable_range_buffer(Range const &range) : read_window(range)
        {
        }

        auto read(value_type *dptr, size_type dsize) -> size_type
        {
            auto can_read = std::min(dsize, read_window.size());

            auto will_read = read_window.subspan(0, can_read);
            auto const *read_data = std::ranges::data(will_read);
            auto read_size = std::ranges::size(will_read);
            std::memcpy(dptr, read_data, read_size);

            discard(can_read);
            return can_read;
        }

        auto readable_ranges() -> std::vector<std::span<const_value_type>>
        {
            return {read_window};
        }

        auto discard(size_type n) -> size_type
        {
            auto will_discard = std::min(n, read_window.size());
            read_window = read_window.subspan(will_discard);
            return will_discard;
        }
    };

    static_assert(readable_buffer<readable_range_buffer<std::span<char>>>);

    // Create a readable_range_buffer from a range.
    template <std::ranges::contiguous_range Range>
    auto make_readable_range_buffer(Range &&range)
    {
        using range_type = std::remove_reference_t<decltype(range)>;
        return readable_range_buffer<range_type>(range);
    }

    /*************************************************************************
     *
     * writable_range_buffer: a writable_buffer that exposes data from a
     * contiguous range.
     */
    template <std::ranges::contiguous_range Range>
    struct writable_range_buffer {
        using value_type = std::ranges::range_value_t<Range>;
        using const_value_type = std::add_const_t<value_type>;
        using size_type = typename std::span<value_type>::size_type;

        std::span<value_type> write_window;

        explicit writable_range_buffer(Range &range) : write_window(range) {}

        auto write(const_value_type *dptr, size_type dsize) -> size_type
        {
            auto can_write =
                std::min(write_window.size(), dsize);
            std::span will_write(dptr, can_write);
            std::ranges::copy(will_write, write_window.begin());
            commit(can_write);
            return can_write;
        }

        auto writable_ranges() -> std::vector<std::span<value_type>>
        {
            return {write_window};
        }

        auto commit(size_type n) -> size_type
        {
            auto will_commit = std::min(write_window.size(), n);
            write_window = write_window.subspan(will_commit);
            return will_commit;
        }
    };

    static_assert(writable_buffer<writable_range_buffer<std::span<char>>>);

    // Create a writable_range_buffer from a range.
    template <std::ranges::contiguous_range Range>
    auto make_writable_range_buffer(Range &&range)
    {
        using range_type = std::remove_reference_t<decltype(range)>;
        return writable_range_buffer<range_type>(range);
    }

} // namespace sk

#endif // SK_BUFFER_RANGE_BUFFER_HXX_INCLUDED
