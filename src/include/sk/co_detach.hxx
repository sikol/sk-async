/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_CO_DETACH_HXX_INCLUDED
#define SK_CO_DETACH_HXX_INCLUDED

#include <sk/detail/coroutine.hxx>
#include <sk/reactor.hxx>

namespace sk {

    struct detach_task {
        struct promise_type {
            executor *task_executor = nullptr;

            auto get_return_object() -> detach_task
            {
                return detach_task(
                    coroutine_handle<promise_type>::from_promise(*this));
            }

            auto initial_suspend() -> suspend_always
            {
                return {};
            }

            auto final_suspend() noexcept -> suspend_never
            {
                return {};
            }

            void unhandled_exception()
            {
                std::rethrow_exception(std::current_exception());
            }

            void return_void() noexcept {}
        };

        coroutine_handle<promise_type> coro_handle;

        explicit detach_task(
            coroutine_handle<promise_type> coro_handle_) noexcept
            : coro_handle(coro_handle_)
        {
        }

        explicit detach_task(detach_task const &) = delete;
        auto operator=(detach_task const &) -> detach_task & = delete;
        auto operator=(detach_task &&other) -> detach_task & = delete;

        detach_task(detach_task &&other) noexcept
            : coro_handle(std::exchange(other.coro_handle, {}))
        {
        }

        ~detach_task()
        {
            if (coro_handle) {
                try {
                    coro_handle.destroy();
                } catch (...) {
                    std::terminate();
                }
            }
        }

        void start()
        {
            auto h = std::exchange(coro_handle, {});
            h.resume();
        }
    };

    template <typename T>
    [[nodiscard]] auto _internal_detach(task<T> &&task_) -> detach_task
    {
        task<T> taskp(std::move(task_));
        auto &promise = taskp.coro_handle.promise();
        promise.previous = {};
        co_await taskp;
    }

    template <typename T>
    [[nodiscard]] auto co_detach(task<T> &&task_, executor *xer = nullptr) -> task<void>
    {
        auto &promise = task_.coro_handle.promise();
        if (xer)
            promise.task_executor = xer;
        else
            promise.task_executor = co_await co_get_executor();

        sk::detail::check(promise.task_executor != nullptr,
                          "_internal_detach: no executor?");

        auto detach_task = _internal_detach(std::move(task_));
        detach_task.start();
    }

} // namespace sk

#endif // SK_CO_DETACH_HXX_INCLUDED
