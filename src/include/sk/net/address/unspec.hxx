/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_NET_ADDRESS_UNSPEC_HXX_INCLUDED
#define SK_NET_ADDRESS_UNSPEC_HXX_INCLUDED

#include <sk/net/address/address.hxx>
#include <sk/net/address/inet.hxx>
#include <sk/net/address/inet6.hxx>
#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
#    include <sk/net/address/unix.hxx>
#endif

namespace sk::net {

    // Address for an unspecified address family.  Historically this would
    // be a sockaddr, but for IPv6 it must be a sockaddr_storage.
    //
    // address<AF_UNSPEC> is used when the address family isn't known at
    // compile time; for example, almost all IP operations will use this
    // because the address family could be either AF_INET or AF_INET6.

    template <>
    struct address<AF_UNSPEC> {
        sockaddr_storage native_address{};

        // Some systems provide this in sockaddr, but others don't.
        // For consistency, store it ourselves.
        socklen_t native_address_length{};

        template <int af>
        auto operator=(address<af> const &from) -> address<AF_UNSPEC>
        {
            static_assert(sizeof(native_address) >= sizeof(from.native_address),
                          "sockaddr_storage is too small");
            std::memcpy(&native_address,
                        &from.native_address,
                        sizeof(from.native_address));
            native_address_length = sizeof(from.native_address);
            return *this;
        }
    };

    using unspecified_address = address<AF_UNSPEC>;

    // Construct an unspecified_address from a sockaddr.
    [[nodiscard]] static auto make_unspecified_address(sockaddr const *ss,
                                                       socklen_t len)
        -> expected<unspecified_address, std::error_code>
    {
        unspecified_address ret;

        if (static_cast<std::size_t>(len) > sizeof(ret.native_address))
            return make_unexpected(
                std::make_error_code(std::errc::value_too_large));

        std::memcpy(&ret.native_address, ss, len);
        ret.native_address_length = len;
        return ret;
    }

    template <>
    [[nodiscard]] inline auto address_family(address<AF_UNSPEC> const &addr)
        -> int
    {
        return addr.native_address.ss_family;
    }

    // unspecified_address <- sockaddr_in
    template <>
    struct address_caster<address<>, sockaddr_in> {
        auto cast(sockaddr_in const &sin)
            -> expected<address<>, std::error_code>
        {
            unspecified_address ret;

            static_assert(sizeof(ret.native_address) >= sizeof(sin),
                          "addess_cast: sockaddr_storage is broken");

            std::memcpy(&ret.native_address, &sin, sizeof(sin));
            ret.native_address_length = sizeof(sin);

            return ret;
        }
    };

    // unspecified_address <- inet_address
    template <>
    struct address_caster<unspecified_address, inet_address> {
        auto cast(inet_address const &addr)
        {
            return address_cast<unspecified_address>(addr.native_address);
        }
    };

    // inet_address <- unspecified_address
    template <>
    struct address_caster<inet_address, unspecified_address> {
        auto cast(unspecified_address const &addr)
            -> expected<inet_address, std::error_code>
        {
            return address_cast<inet_address>(addr.native_address);
        }
    };

    // unspecified_address <- sockaddr_in6

    template <>
    struct address_caster<address<>, sockaddr_in6> {
        auto cast(sockaddr_in6 const &sin)
            -> expected<address<>, std::error_code>
        {
            unspecified_address ret;

            static_assert(sizeof(ret.native_address) >= sizeof(sin),
                          "addess_cast: sockaddr_storage is broken");

            std::memcpy(&ret.native_address, &sin, sizeof(sin));
            ret.native_address_length = sizeof(sin);

            return ret;
        }
    };

    // unspecified_address <- inet6_address
    template <>
    struct address_caster<unspecified_address, inet6_address> {
        auto cast(inet6_address const &addr)
        {
            return address_cast<unspecified_address>(addr.native_address);
        }
    };

    // inet6_address <- unspecified_address
    template <>
    struct address_caster<inet6_address, unspecified_address> {
        auto cast(unspecified_address const &addr)
            -> expected<inet6_address, std::error_code>
        {
            return address_cast<inet6_address>(addr.native_address);
        }
    };

    // unspecified_address <- sockaddr_un

    template <>
    struct address_caster<address<>, sockaddr_un> {
        auto cast(sockaddr_un const &sun)
            -> expected<address<>, std::error_code>
        {
            unspecified_address ret;

            static_assert(
                sizeof(ret.native_address) >= sizeof(sun),
                "addess_cast: sockaddr_storage is too small for AF_UNIX");

            std::memcpy(&ret.native_address, &sun, sizeof(sun));
            ret.native_address_length = sizeof(sun);

            return ret;
        }
    };

    // unspecified_address <- unix_address
    template <>
    struct address_caster<unspecified_address, unix_address> {
        auto cast(unix_address const &addr)
        {
            return address_cast<unspecified_address>(addr.native_address);
        }
    };

    // unix_address <- unspecified_address
    template <>
    struct address_caster<unix_address, unspecified_address> {
        auto cast(unspecified_address const &addr)
            -> expected<unix_address, std::error_code>
        {
            return address_cast<unix_address>(addr.native_address);
        }
    };

    inline auto str(unspecified_address const &addr)
        -> expected<std::string, std::error_code>
    {
        switch (address_family(addr)) {
        case AF_INET:
            return str(*address_cast<inet_address>(addr));

        case AF_INET6:
            return str(*address_cast<inet6_address>(addr));

#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
        case AF_UNIX:
            return str(*address_cast<unix_address>(addr));
#endif

        default:
            return make_unexpected(
                std::make_error_code(std::errc::address_family_not_supported));
        }
    }

    template <int af>
    auto port(address<af> const &addr) -> expected<int, std::error_code>
    {
        switch (af) {
        case AF_INET:
            return addr.port();

        case AF_INET6:
            return addr.port();

        case AF_UNSPEC:
            break;

        default:
            return make_unexpected(
                std::make_error_code(std::errc::address_family_not_supported));
        }

        switch (addr.native_address.ss_family) {
        case AF_INET:
            return ntohs(reinterpret_cast<sockaddr_in *>(&addr.native_address)
                             ->sin_port);
        case AF_INET6:
            return ntohs(reinterpret_cast<sockaddr_in6 *>(&addr.native_address)
                             ->sin6_port);
        default:
            return make_unexpected(
                std::make_error_code(std::errc::address_family_not_supported));
        }
    }

} // namespace sk::net
#endif // SRC_INCLUDE_SK_NET_ADDRESS_UNSPEC_HXX_INCLUDED
