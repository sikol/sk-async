/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_DETAIL_TRACE_HXX
#define SK_DETAIL_TRACE_HXX

#include <cstdlib>
#include <iostream>

namespace sk::detail {

    [[noreturn]] inline auto
    unexpected(char const *file, int line, char const *what) noexcept -> void
    {
        std::cerr << "<<< sk-cio detected a fatal internal inconsistency >>>\n";
        std::cerr << "    at file: " << file << '\n';
        std::cerr << "       line: " << line << '\n';
        std::cerr << "      error: " << what << '\n';
        std::cerr << "<<< The program will now terminate. >>>\n";
        std::abort();
    }

#define SK_UNEXPECTED(what)                                                    \
    do {                                                                       \
        ::sk::detail::unexpected(__FILE__, __LINE__, what);                    \
    } while (0)

} // namespace sk::detail

/*************************************************************************
 * SK_CHECK: conditional assert for debug builds.
 */

#ifndef NDEBUG

#    define SK_CHECKED

#    define SK_CHECK(cond, msg)                                                \
        do {                                                                   \
            if (!(cond)) {                                                     \
                SK_UNEXPECTED(                                                 \
                    (std::string("invariant failure: ") + (msg)).c_str());     \
            }                                                                  \
        } while (0)

#else

#    define SK_CHECK(cond, msg) ((void)0)

#endif

#ifdef SK_ENABLE_TRACING
#    include <array>
#    include <cstdio>
#    include <cstdlib>
#    include <iostream>
#    include <mutex>

#    include <fmt/core.h>

namespace sk::detail {

    [[nodiscard]] inline auto tracing_enabled() -> bool
    {
        static std::atomic<int> enabled;

        switch (enabled) {
        case 1:
            return true;

        case -1:
            return false;

        default:
#    ifdef _WIN32
            std::array<char, 16> buf{};
            const char *s = buf.data();
            size_t size{};
            auto err = getenv_s(&size, buf.data(), buf.size(), "SK_TRACE");
            if (err != 0 || size == 0)
                s = nullptr;
#    else
            char const *s = std::getenv("SK_TRACE");
#    endif
            if (s != nullptr && (*s != 0)) {
                enabled = 1;
                return true;
            }

            enabled = -1;
            return false;
        }
    }

    inline std::mutex print_guard;

    template <typename... Args>
    inline auto trace_print(Args &&...args) -> void
    {
        std::string s(fmt::format(std::forward<Args>(args)...));

        std::lock_guard lock(print_guard);
        std::cerr.write(s.data(), static_cast<std::streamsize>(s.size()));
        std::cerr.write("\n", 1);
    }

#    define SK_TRACE(...)                                                      \
        do {                                                                   \
            if (::sk::detail::tracing_enabled()) {                             \
                ::sk::detail::trace_print(__VA_ARGS__);                        \
            }                                                                  \
        } while (0)

} // namespace sk::detail

#else

#    define SK_TRACE(...) ((void)0)

#endif

#endif // SK_DETAIL_TRACE_HXX
