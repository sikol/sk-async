/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_RADIX_HXX_INCLUDED
#define SK_RADIX_HXX_INCLUDED

#include <climits>
#include <concepts>
#include <cstdio>
#include <cstdlib>
#include <memory>
#include <ranges>
#include <span>
#include <vector>

#include <fmt/core.h>

namespace sk {

    template <std::unsigned_integral T>
    struct bitstring {
        static constexpr unsigned max_len = std::numeric_limits<T>::digits;
        static constexpr T one = T(1) << (max_len - 1);
        static constexpr T zero = 0;
        T value = 0;
        unsigned len = 0;

        auto mask_for_bit(unsigned bit) const -> T
        {
            return one >> bit;
        }

        void set(unsigned bit)
        {
            value |= mask_for_bit(bit);
        }

        void clr(unsigned bit)
        {
            value &= ~mask_for_bit(bit);
        }

        auto mask() const -> T
        {
            return T(~0) << (max_len - len);
        }

        void append(bool bit)
        {
            assert(len < max_len);
            if (bit)
                set(len);
            else
                clr(len);
            ++len;
        }

        void append(bitstring const &other)
        {
            assert(len + other.len < max_len);
            value |= (other.value >> len);
            len += other.len;
        }

        auto test(unsigned bit) const -> bool
        {
            assert(bit < len);
            return (value & mask_for_bit(bit)) ? 1 : 0;
        }

        auto operator[](unsigned bit) const -> bool
        {
            return test(bit);
        }

        auto str() const -> std::string
        {
            std::string r;

            for (unsigned i = 0; i < len; ++i)
                r += test(i) ? '1' : '0';

            return r;
        }

        auto vec() const -> std::vector<bool>
        {
            std::vector<bool> r;

            for (unsigned i = 0; i < len; ++i)
                r.push_back(test(i));

            return r;
        }

        auto operator=(std::vector<bool> const &other) -> bitstring &
        {
            reset();
            for (auto &&bit : other)
                append(bit);
            return *this;
        }

        auto operator=(bitstring const &other) -> bitstring &
        {
            if (&other != this) {
                value = other.value;
                len = other.len;
            }
            return *this;
        }

        auto operator=(std::string const &v) -> bitstring &
        {
            reset();
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
            return *this;
        }

        auto reset() -> void
        {
            value = 0;
            len = 0;
        }

        auto size() -> unsigned
        {
            return len;
        }

        bitstring() = default;

        bitstring(T value_, unsigned len_) : value(value_), len(len_)
        {
            value &= mask();
        }

        bitstring(bitstring const &other) : value(other.value), len(other.len)
        {
        }

        explicit bitstring(std::string const &v)
        {
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
        }

        explicit bitstring(char const *s) : bitstring(std::string(s)) {}

        explicit bitstring(std::byte const *bstart, std::byte const *bend)
        {
            while (bstart < bend) {
                value |= (static_cast<T>(*bstart) << (max_len - (len + 8)));
                len += 8;
                ++bstart;
            }
        }

        explicit bitstring(std::vector<bool> const &bits)
        {
            for (auto &&bit : bits)
                append(bit);
        }
    };

    template <std::unsigned_integral T>
    inline auto common_prefix(bitstring<T> const &a, bitstring<T> const &b)
    {
        unsigned len = std::min(a.len, b.len);
        T mask = (~T(0)) << (bitstring<T>::max_len - len);
        unsigned bits = std::countl_zero((a.value & mask) ^ (b.value & mask));
        return bitstring<T>(a.value & mask, std::min(bits, len));
    }

    template <std::unsigned_integral T>
    inline auto operator+(bitstring<T> const &a, bitstring<T> const &b)
    {
        auto r(a);
        r.append(b);
        return r;
    }

    template <std::unsigned_integral T>
    inline auto operator<<(bitstring<T> const &b, unsigned bits)
    {
        auto r(b);
        assert(r.len >= bits);
        r.len -= bits;
        r.value <<= bits;
        return r;
    }

    template <std::unsigned_integral T>
    auto operator==(bitstring<T> const &a, bitstring<T> const &b)
    {
        return a.value == b.value && a.len == b.len;
    }

    template <unsigned chunks, typename T = std::uint8_t>
    struct multi_bitstring {
        unsigned const max_len = std::numeric_limits<T>::digits * chunks;
        static constexpr unsigned max_value_len =
            std::numeric_limits<T>::digits;
        static constexpr T one = T(1) << (std::numeric_limits<T>::digits - 1);

        std::array<T, chunks> values;
        unsigned len = 0;

        multi_bitstring() = default;

        multi_bitstring(multi_bitstring const &other)
            : values(other.values), len(other.len)
        {
        }

        explicit multi_bitstring(std::string const &v)
        {
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
        }

        explicit multi_bitstring(char const *s)
            : multi_bitstring(std::string(s))
        {
        }

        explicit multi_bitstring(std::byte const *bstart, std::byte const *bend)
        {
            std::memcpy(values.data(), bstart, bend - bstart);
            len = std::distance(bstart, bend) * 8;
        }

        auto operator=(std::string const &v) -> multi_bitstring &
        {
            reset();
            for (auto &&b : v) {
                if (b == '\'')
                    continue;

                append(b == '1' ? 1 : 0);
            }
            return *this;
        }

        auto value_for_bit(unsigned bit) const -> T const &
        {
            auto n = bit / max_value_len;
            assert(n < chunks);
            return values[n];
        }

        auto value_for_bit(unsigned bit) -> T &
        {
            return const_cast<T &>(
                static_cast<multi_bitstring const *>(this)->value_for_bit(bit));
        }

        auto bit_for_bit(unsigned bit) const -> unsigned
        {
            auto n = bit % max_value_len;
            return n;
        }

        auto mask_for_bit(unsigned bit) const -> T
        {
            return one >> bit_for_bit(bit);
        }

        void set(unsigned bit)
        {
            value_for_bit(bit) |= mask_for_bit(bit_for_bit(bit));
            assert(test(bit));
        }

        void clr(unsigned bit)
        {
            value_for_bit(bit) &= ~mask_for_bit(bit_for_bit(bit));
            assert(!test(bit));
        }

        auto test(unsigned bit) const -> bool
        {
            // assert(bit < len);
            return (value_for_bit(bit) & mask_for_bit(bit)) ? 1 : 0;
        }

        void append(bool bit)
        {
            assert(len + 1 <= max_len);

            if (bit)
                set(len);
            else
                clr(len);

            ++len;
        }

        auto str() const -> std::string
        {
            std::string r;

            for (unsigned i = 0; i < len; ++i)
                r += test(i) ? '1' : '0';

            return r;
        }

        auto reset() -> void
        {
            len = 0;
        }

        auto operator[](unsigned bit) const -> bool
        {
            return test(bit);
        }

        auto operator=(multi_bitstring const &other) -> multi_bitstring &
        {
            if (&other != this) {
                len = other.len;
                std::ranges::copy(other.values, values.begin());
            }

            return *this;
        }

        auto size() -> unsigned
        {
            return len;
        }

        void append(multi_bitstring const &other)
        {
            assert(len + other.len < max_len);

            unsigned n = other.len;
            auto *this_value = &value_for_bit(len + 1);
            auto *other_value = &other.value_for_bit(0);
            unsigned offs = len % max_value_len;

            // fmt::print("\n\nappend: len={} other.len={} offs={}\n",
            //           len,
            //           other.len,
            //           offs);

            while (n) {
                unsigned can = std::min(n, max_value_len);
                auto next_value = this_value + 1;

                // int can_ = std::min(can, max_value_len - (len %
                // max_value_len));

                *this_value &= ~(T(~0) >> offs);

                // fmt::print("  n={} can={} this_value={:08b}
                // other_value={:08b}\n",
                //           n, can,
                //           *this_value,
                //           *other_value);

                *this_value |= *other_value >> offs;

                // fmt::print("  now this_value={:08b}", *this_value);
                if ((can + offs) > max_value_len) {
                    *next_value = (*other_value << (max_value_len - offs));
                    // fmt::print(", next_value={:08b}", *next_value);
                    //*next_value += can - can_;
                }
                // fmt::print("\n");
                ++this_value;
                ++other_value;
                len += can;
                n -= can;
            }
        }

#if 0
        bitstring(T value_, unsigned len_) : value(value_), len(len_)
        {
            value &= mask();
        }

        explicit bitstring(std::vector<bool> const &bits)
        {
            for (auto &&bit : bits)
                append(bit);
        }
#endif
    };

    template <unsigned chunks, std::unsigned_integral T>
    inline auto common_prefix(multi_bitstring<chunks, T> const &a,
                              multi_bitstring<chunks, T> const &b)
    {
        multi_bitstring<chunks, T> ret(a);

        unsigned minlen = std::min(a.len, b.len);
        unsigned bits_left = minlen;

        //fmt::print("\n\ncommon_prefix: minlen={}\n", minlen);

        for (unsigned i = 0; i < chunks; ++i) {
            //fmt::print("  loop i={} bits_left={}\n", i, bits_left);
            if (bits_left > ret.max_value_len && (a.values[i] == b.values[i])) {
                bits_left -= ret.max_value_len;
                continue;
            }

            unsigned len = ret.bit_for_bit(std::min(a.len, b.len));
            if (len == 0)
                len = ret.max_value_len;

            T mask = T(~0) << (ret.max_value_len - len);
            //fmt::print(
            //    "len={} mask={:08b},\n         a={:08b}\n         b={:08b}\n",
            //    len,
            //    mask,
            //    a.values[i],
            //    b.values[i]);

            T xor_ = T(T(a.values[i] & mask) ^ T(b.values[i] & mask));
            //fmt::print("xor={:08b}\n", xor_);

            unsigned bits = std::countl_zero(
                T(T(a.values[i] & mask) ^ T(b.values[i] & mask)));
            if (bits > len)
                bits = len;

            ret.len = i * (sizeof(T) * CHAR_BIT) + std::min(ret.len, bits);
            //fmt::print("i={}, a.len={}, b.len={}, bits={}, ret.len={}\n",
            //           i,
            //           a.len,
            //           b.len,
            //           bits,
            //           ret.len);
            break;
        }

        return ret;
    }

    template <unsigned chunks, std::unsigned_integral T>
    inline auto operator+(multi_bitstring<chunks, T> const &a,
                          multi_bitstring<chunks, T> const &b)
    {
        auto r(a);
        r.append(b);
        return r;
    }

    template <unsigned chunks, std::unsigned_integral T>
    inline auto operator<<(multi_bitstring<chunks, T> const &b, unsigned bits)
    {
        auto r(b);
        assert(r.len >= bits);

        auto *this_value = &r.values[0];
        int offs = bits / r.max_value_len;
        auto *shift_value = &r.values[0] + offs;
        // fmt::print("\n<< bits={} offs={} this_value={:08b}
        // shift_value={:08b}\n", bits, offs,
        //           *this_value, *shift_value);

        int shift = bits % r.max_value_len;

        for (unsigned i = 0; i < chunks; ++i) {
            // fmt::print("\n  i={} r.values[i]={:08b} shift_value={:08b}\n", i,
            // r.values[i], *shift_value);
            if (shift_value < (r.values.data() + r.values.size()))
                r.values[i] = *shift_value << shift;

            // fmt::print("    -> r.values[i]={:08b}\n", r.values[i]);

            if (shift_value + 1 < (r.values.data() + r.values.size()))
                r.values[i] |=
                    T(*(shift_value + 1)) >> (sizeof(T) * CHAR_BIT - shift);

            // fmt::print("    -> r.values[i]={:08b}\n", r.values[i]);
            shift_value++;
        }

        r.len -= bits;
        return r;
    }

    enum struct radix_op : int {
        insert,
        find,
        remove,
    };

    template <typename T>
    struct radix_node {
        using node_ptr = std::unique_ptr<radix_node>;
        using string_type = multi_bitstring<8, std::uint8_t>;

        radix_node() = default;

        radix_node(string_type const &s) : istring(s) {}

        auto add_node(std::unique_ptr<radix_node<T>> &&n) -> node_ptr &
        {
            auto &branch = n->istring[0] ? right : left;
            assert(branch.get() == nullptr);
            branch = std::move(n);
            return branch;
        }

        static constexpr unsigned max_string = 64;
        string_type istring;
        std::optional<T> value;

        node_ptr left, right;

        auto find(string_type ir, radix_op op) -> radix_node<T> *
        {
            //fmt::print("find: ir={} size={}\n", ir.str(), ir.size());

            // If r is empty, we are the edge for this string.
            if (ir.size() == 0) {
                //fmt::print("  got end\n");
                if (op == radix_op::remove)
                    value.reset();

                return this;
            }

            //fmt::print(
            //    "  first bit={}, take {}\n", ir[0], ir[0] ? "right" : "left");

            // Look for an existing edge.
            auto &e = ir[0] ? right : left;

            if (!e) {
                if (op != radix_op::insert)
                    return nullptr;

                //fmt::print("  no node here, inserting\n");
                auto &new_edge = add_node(std::make_unique<radix_node>(ir));
                return new_edge.get();
            }

            auto pfx = common_prefix(ir, e->istring);

            //fmt::print("ir={:24}\n", ir.str());
            //fmt::print(" e={:24}\n", e->istring.str());
            //fmt::print(" p={:24}\n", pfx.str());

            auto matchlen = pfx.size();

            assert(matchlen < max_string);
            assert(matchlen > 0);

            if (matchlen == e->istring.size()) {
                auto br = ir << pfx.size();
                auto ret = e->find(br, op);
                if (op != radix_op::remove)
                    return ret;

                if (!e->value) {
                    if (!e->left && !e->right) {
                        // If the child node has no value and no children,
                        // kill it.
                        e.reset();
                        return this;
                    }

                    if (!(e->left && e->right)) {
                        auto &steal = e->left ? e->left : e->right;
                        // If the child only has a single edge, unsplit it.
                        steal->istring = e->istring + steal->istring;
                        e = std::move(steal);
                        return this;
                    }
                }

                return ret;
            }

            if (op != radix_op::insert)
                return nullptr;

            // Found a partial substring, split into two children.
            auto new_node = std::make_unique<radix_node>(pfx);
            e->istring = e->istring << matchlen;

            new_node->add_node(std::move(e));
            e = std::move(new_node);

            auto nr = ir << pfx.size();
            return e->find(nr, op);
        }
    };

    template <typename Char, typename T>
    struct radix_tree {
        radix_node<T> root;

        template <std::ranges::contiguous_range Range>
        auto insert(Range &&r, T const &value) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::insert);
            if (node->value)
                return false;

            node->value.emplace(value);
            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto remove(Range &&r) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::remove);

            if (!node)
                return false;

            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto find(Range &&r) -> T *
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto node = root.find(bs, radix_op::find);

            if (!node)
                return nullptr;

            if (!node->value)
                return nullptr;

            return &*node->value;
        }
    };

} // namespace sk

#endif // SK_RADIX_HXX_INCLUDED
