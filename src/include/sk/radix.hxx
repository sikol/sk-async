/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_RADIX_HXX_INCLUDED
#define SK_RADIX_HXX_INCLUDED

#include <climits>
#include <concepts>
#include <cstdio>
#include <cstdlib>
#include <memory>
#include <ranges>
#include <span>
#include <vector>

#include <fmt/core.h>

namespace sk {

    template <std::unsigned_integral T>
    struct bitstring {
        static constexpr unsigned max_len = std::numeric_limits<T>::digits;
        static constexpr T one = T(1) << (max_len - 1);
        static constexpr T zero = 0;
        T value = 0;
        unsigned len = 0;

        auto mask_for_bit(unsigned bit) const -> T
        {
            return one >> bit;
        }

        void set(unsigned bit)
        {
            value |= mask_for_bit(bit);
        }

        void clr(unsigned bit)
        {
            value &= ~mask_for_bit(bit);
        }

        auto mask() const -> T
        {
            return ~zero << (max_len - len);
        }

        void append(bool bit)
        {
            assert(len + 1 < max_len);
            if (bit)
                set(len);
            else
                clr(len);
            ++len;
        }

        void append(bitstring const &other)
        {
            assert(len + other.len < max_len);
            value |= (other.value >> len);
            len += other.len;
        }

        auto test(unsigned bit) const -> bool
        {
            assert(bit < len);
            return (value & mask_for_bit(bit)) ? 1 : 0;
        }

        auto operator[](unsigned bit) const -> bool
        {
            return test(bit);
        }

        auto str() const -> std::string
        {
            std::string r;

            for (unsigned i = 0; i < len; ++i)
                r += test(i) ? '1' : '0';

            return r;
        }

        auto vec() const -> std::vector<bool>
        {
            std::vector<bool> r;

            for (unsigned i = 0; i < len; ++i)
                r.push_back(test(i));

            return r;
        }

        auto operator=(std::vector<bool> const &other) -> bitstring &
        {
            reset();
            for (auto &&bit : other)
                append(bit);
            return *this;
        }

        auto operator=(bitstring const &other) -> bitstring &
        {
            if (&other != this) {
                value = other.value;
                len = other.len;
            }
            return *this;
        }

        auto operator=(std::string const &v) -> bitstring &
        {
            reset();
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
            return *this;
        }

        auto reset() -> void
        {
            value = 0;
            len = 0;
        }

        auto size() -> unsigned
        {
            return len;
        }

        bitstring() = default;

        bitstring(T value_, unsigned len_) : value(value_), len(len_)
        {
            value &= mask();
        }

        bitstring(bitstring const &other) : value(other.value), len(other.len)
        {
        }

        explicit bitstring(std::string const &v)
        {
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
        }

        explicit bitstring(char const *s) : bitstring(std::string(s)) {}

#if 0
        template <std::ranges::range Range>
        explicit bitstring(Range const &r)
        {
            for (auto v : r)
                append(v);
        }
#endif

        explicit bitstring(std::byte const *bstart, std::byte const *bend)
        {
            while (bstart < bend) {
                value |= (static_cast<T>(*bstart) << (max_len - (len + 8)));
                len += 8;
                ++bstart;
            }
        }

        explicit bitstring(std::vector<bool> const &bits)
        {
            for (auto &&bit : bits)
                append(bit);
        }
    };

    template <std::unsigned_integral T>
    inline auto common_prefix(bitstring<T> const &a, bitstring<T> const &b)
    {
        unsigned len = std::min(a.len, b.len);
        T mask = (~T(0)) << (bitstring<T>::max_len - len);
        unsigned bits = std::countl_zero((a.value & mask) ^ (b.value & mask));
        return bitstring<T>(a.value & mask, std::min(bits, len));
    }

    template <std::unsigned_integral T>
    inline auto operator+(bitstring<T> const &a, bitstring<T> const &b)
    {
        auto r(a);
        r.append(b);
        return r;
    }

    template <std::unsigned_integral T>
    inline auto operator<<(bitstring<T> const &b, unsigned bits)
    {
        auto r(b);
        assert(r.len >= bits);
        r.len -= bits;
        r.value <<= bits;
        return r;
    }

    enum struct radix_op : int {
        insert,
        find,
        remove,
    };

    template <typename T>
    struct radix_node {
        using node_ptr = std::unique_ptr<radix_node>;
        using string_type = bitstring<std::uint64_t>;

        radix_node() = default;

        radix_node(string_type const &s) : istring(s) {}

        auto add_node(std::unique_ptr<radix_node<T>> &&n) -> node_ptr &
        {
            auto &branch = n->istring[0] ? right : left;
            assert(branch.get() == nullptr);
            branch = std::move(n);
            return branch;
        }

        static constexpr unsigned max_string = 64;
        string_type istring;
        std::optional<T> value;

        node_ptr left, right;

        auto find(string_type ir, radix_op op) -> radix_node<T> *
        {
            // If r is empty, we are the edge for this string.
            if (ir.size() == 0) {
                if (op == radix_op::remove)
                    value.reset();

                return this;
            }

            // Look for an existing edge.
            auto &e = ir[0] ? right : left;

            if (!e) {
                if (op != radix_op::insert)
                    return nullptr;

                auto &new_edge = add_node(std::make_unique<radix_node>(ir));
                return new_edge.get();
            }

            auto pfx = common_prefix(ir, e->istring);

            auto matchlen = pfx.size();

            assert(matchlen < max_string);
            assert(matchlen > 0);

            // if (matchlen == stdr::size(e->string)) {
            if (matchlen == e->istring.size()) {
                auto br = ir << pfx.size();
                auto ret = e->find(br, op);
                if (op != radix_op::remove)
                    return ret;

                if (!e->value) {
                    if (!e->left && !e->right) {
                        // If the child node has no value and no children,
                        // kill it.
                        e.reset();
                        return this;
                    }

                    if (!(e->left && e->right)) {
                        auto &steal = e->left ? e->left : e->right;
                        // If the child only has a single edge, unsplit it.
                        steal->istring = e->istring + steal->istring;
                        e = std::move(steal);
                        return this;
                    }
                }

                return ret;
            }

            if (op != radix_op::insert)
                return nullptr;

            // Found a partial substring, split into two children.
            auto new_node = std::make_unique<radix_node>(pfx);
            e->istring = e->istring << matchlen;

            new_node->add_node(std::move(e));
            e = std::move(new_node);

            auto nr = ir << pfx.size();
            return e->find(nr, op);
        }
    };

    template <typename Char, typename T>
    struct radix_tree {
        radix_node<T> root;

        template <std::ranges::contiguous_range Range>
        auto insert(Range &&r, T const &value) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::insert);
            if (node->value)
                return false;

            node->value.emplace(value);
            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto remove(Range &&r) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::remove);

            if (!node)
                return false;

            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto find(Range &&r) -> T *
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto node = root.find(bs, radix_op::find);

            if (!node)
                return nullptr;

            if (!node->value)
                return nullptr;

            return &*node->value;
        }
    };

} // namespace sk

#endif // SK_RADIX_HXX_INCLUDED
