/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_RADIX_HXX_INCLUDED
#define SK_RADIX_HXX_INCLUDED

#include <climits>
#include <concepts>
#include <cstdio>
#include <cstdlib>
#include <memory>
#include <ranges>
#include <span>
#include <vector>

#include <fmt/core.h>

namespace sk {

    template <unsigned chunks, typename T = std::uint8_t>
    struct multi_bitstring {
        unsigned const max_len = std::numeric_limits<T>::digits * chunks;
        static constexpr unsigned max_value_len =
            std::numeric_limits<T>::digits;
        static constexpr T one = T(1) << (std::numeric_limits<T>::digits - 1);

        std::array<T, chunks> values;
        unsigned len = 0;

        multi_bitstring() = default;

        multi_bitstring(multi_bitstring const &other)
            : values(other.values), len(other.len)
        {
        }

        explicit multi_bitstring(std::string const &v)
        {
            for (auto &&b : v)
                append(b == '1' ? 1 : 0);
        }

        explicit multi_bitstring(char const *s)
            : multi_bitstring(std::string(s))
        {
        }

        explicit multi_bitstring(std::byte const *bstart, std::byte const *bend)
            : values{}
        {
            len = std::distance(bstart, bend) * 8;

            if (sizeof(T) == 1 || (std::endian::native == std::endian::big)) {
                std::memcpy(values.data(), bstart, bend - bstart);
            } else {
                auto *value = values.begin();
                unsigned shift = max_value_len - 8;

                while (bstart < bend) {
                    *value |= static_cast<T>(*bstart) << shift;
                    if (shift == 0) {
                        value++;
                        shift = max_value_len - 8;
                    } else {
                        shift -= 8;
                    }
                    bstart++;
                }
            }
        }

        auto operator=(std::string const &v) -> multi_bitstring &
        {
            reset();
            for (auto &&b : v) {
                if (b == '\'')
                    continue;

                append(b == '1' ? 1 : 0);
            }
            return *this;
        }

        auto value_for_bit(unsigned bit) const -> T const &
        {
            auto n = bit / max_value_len;
            assert(n < chunks);
            return values[n];
        }

        auto value_for_bit(unsigned bit) -> T &
        {
            return const_cast<T &>(
                static_cast<multi_bitstring const *>(this)->value_for_bit(bit));
        }

        auto bit_for_bit(unsigned bit) const -> unsigned
        {
            auto n = bit % max_value_len;
            return n;
        }

        auto mask_for_bit(unsigned bit) const -> T
        {
            return one >> bit_for_bit(bit);
        }

        void set(unsigned bit)
        {
            value_for_bit(bit) |= mask_for_bit(bit_for_bit(bit));
            assert(test(bit));
        }

        void clr(unsigned bit)
        {
            value_for_bit(bit) &= ~mask_for_bit(bit_for_bit(bit));
            assert(!test(bit));
        }

        auto test(unsigned bit) const -> bool
        {
            assert(bit <= len);
            return (value_for_bit(bit) & mask_for_bit(bit)) ? 1 : 0;
        }

        void append(bool bit)
        {
            assert(len + 1 <= max_len);

            if (bit)
                set(len);
            else
                clr(len);

            ++len;
        }

        auto str() const -> std::string
        {
            std::string r;

            for (unsigned i = 0; i < len; ++i)
                r += test(i) ? '1' : '0';

            return r;
        }

        auto reset() -> void
        {
            len = 0;
        }

        auto operator[](unsigned bit) const -> bool
        {
            return test(bit);
        }

        auto operator=(multi_bitstring const &other) -> multi_bitstring &
        {
            if (&other != this) {
                len = other.len;
                std::ranges::copy(other.values, values.begin());
            }

            return *this;
        }

        auto size() -> unsigned
        {
            return len;
        }

        void append(multi_bitstring const &other)
        {
            assert(len + other.len < max_len);

            unsigned n = other.len;
            auto *this_value = &value_for_bit(len + 1);
            auto *other_value = &other.value_for_bit(0);
            unsigned offs = len % max_value_len;

            while (n) {
                unsigned can = std::min(n, max_value_len);
                auto next_value = this_value + 1;

                *this_value &= ~(T(~0) >> offs);
                *this_value |= *other_value >> offs;

                if ((can + offs) > max_value_len)
                    *next_value = (*other_value << (max_value_len - offs));

                ++this_value;
                ++other_value;
                len += can;
                n -= can;
            }
        }
    };

    template <unsigned chunks, std::unsigned_integral T>
    inline auto common_prefix(multi_bitstring<chunks, T> const &a,
                              multi_bitstring<chunks, T> const &b)
    {
        multi_bitstring<chunks, T> ret(a);

        unsigned minlen = std::min(a.len, b.len);
        unsigned bits_left = minlen;

        for (unsigned i = 0; i < chunks; ++i) {
            if (bits_left > ret.max_value_len && (a.values[i] == b.values[i])) {
                bits_left -= ret.max_value_len;
                continue;
            }

            unsigned len = ret.bit_for_bit(std::min(a.len, b.len));
            if (len == 0)
                len = ret.max_value_len;

            T mask = T(~0) << (ret.max_value_len - len);

            unsigned bits = std::countl_zero(
                T(T(a.values[i] & mask) ^ T(b.values[i] & mask)));
            if (bits > len)
                bits = len;

            ret.len = i * (sizeof(T) * CHAR_BIT) + std::min(ret.len, bits);
            break;
        }

        return ret;
    }

    template <unsigned chunks, std::unsigned_integral T>
    inline auto operator+(multi_bitstring<chunks, T> const &a,
                          multi_bitstring<chunks, T> const &b)
    {
        auto r(a);
        r.append(b);
        return r;
    }

    template <unsigned chunks, std::unsigned_integral T>
    inline auto operator<<(multi_bitstring<chunks, T> const &b, unsigned bits)
    {
        auto r(b);
        assert(r.len >= bits);

        int offs = bits / r.max_value_len;
        auto *shift_value = &r.values[0] + offs;

        int shift = bits % r.max_value_len;
        unsigned bits_left = r.len;

        for (unsigned i = 0; i < chunks; ++i) {
            if (!bits_left)
                break;

            r.values[i] = *shift_value << shift;

            if (shift_value + 1 < (r.values.data() + r.values.size()))
                r.values[i] |=
                    T(*(shift_value + 1)) >> (r.max_value_len - shift);

            shift_value++;
            bits_left -= r.max_value_len;
        }

        r.len -= bits;
        return r;
    }

    enum struct radix_op : int {
        insert,
        find,
        remove,
    };

    template <typename T>
    struct radix_node {
        using node_ptr = std::unique_ptr<radix_node>;
        using string_type = multi_bitstring<1, std::uint64_t>;

        radix_node() = default;

        radix_node(string_type const &s) : istring(s) {}

        auto add_node(std::unique_ptr<radix_node<T>> &&n) -> node_ptr &
        {
            auto &branch = n->istring[0] ? right : left;
            assert(branch.get() == nullptr);
            branch = std::move(n);
            return branch;
        }

        static constexpr unsigned max_string = 64;
        string_type istring;
        std::optional<T> value;

        node_ptr left, right;

        auto find(string_type ir, radix_op op) -> radix_node<T> *
        {
            // If r is empty, we are the edge for this string.
            if (ir.size() == 0) {
                if (op == radix_op::remove)
                    value.reset();

                return this;
            }

            // Look for an existing edge.
            auto &e = ir[0] ? right : left;

            if (!e) {
                if (op != radix_op::insert)
                    return nullptr;

                auto &new_edge = add_node(std::make_unique<radix_node>(ir));
                return new_edge.get();
            }

            auto pfx = common_prefix(ir, e->istring);

            auto matchlen = pfx.size();

            assert(matchlen < max_string);
            assert(matchlen > 0);

            if (matchlen == e->istring.size()) {
                auto br = ir << pfx.size();
                auto ret = e->find(br, op);
                if (op != radix_op::remove)
                    return ret;

                if (!e->value) {
                    if (!e->left && !e->right) {
                        // If the child node has no value and no children,
                        // kill it.
                        e.reset();
                        return this;
                    }

                    if (!(e->left && e->right)) {
                        auto &steal = e->left ? e->left : e->right;
                        // If the child only has a single edge, unsplit it.
                        steal->istring = e->istring + steal->istring;
                        e = std::move(steal);
                        return this;
                    }
                }

                return ret;
            }

            if (op != radix_op::insert)
                return nullptr;

            // Found a partial substring, split into two children.
            auto new_node = std::make_unique<radix_node>(pfx);
            e->istring = e->istring << matchlen;

            new_node->add_node(std::move(e));
            e = std::move(new_node);

            auto nr = ir << pfx.size();
            return e->find(nr, op);
        }
    };

    template <typename Char, typename T>
    struct radix_tree {
        radix_node<T> root;

        template <std::ranges::contiguous_range Range>
        auto insert(Range &&r, T const &value) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::insert);
            if (node->value)
                return false;

            node->value.emplace(value);
            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto remove(Range &&r) -> bool
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto *node = root.find(bs, radix_op::remove);

            if (!node)
                return false;

            return true;
        }

        template <std::ranges::contiguous_range Range>
        auto find(Range &&r) -> T *
        {
            auto dstart =
                reinterpret_cast<std::byte const *>(std::ranges::data(r));
            auto dend = dstart + std::ranges::size(r) *
                                     sizeof(std::ranges::range_value_t<Range>);
            typename radix_node<T>::string_type bs(dstart, dend);

            auto node = root.find(bs, radix_op::find);

            if (!node)
                return nullptr;

            if (!node->value)
                return nullptr;

            return &*node->value;
        }
    };

} // namespace sk

#endif // SK_RADIX_HXX_INCLUDED
