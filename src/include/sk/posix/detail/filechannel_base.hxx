/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_POSIX_DETAIL_FILECHANNEL_BASE_HXX
#define SK_POSIX_DETAIL_FILECHANNEL_BASE_HXX

#include <sys/types.h>
#include <fcntl.h>

#include <filesystem>
#include <system_error>

#include <sk/async_invoke.hxx>
#include <sk/buffer/buffer.hxx>
#include <sk/channel/concepts.hxx>
#include <sk/channel/error.hxx>
#include <sk/channel/types.hxx>
#include <sk/co_detach.hxx>
#include <sk/detail/safeint.hxx>
#include <sk/posix/error.hxx>
#include <sk/posix/fd.hxx>
#include <sk/reactor.hxx>
#include <sk/task.hxx>
#include <sk/wait.hxx>

namespace sk::posix::detail {

    /*************************************************************************
     *
     * filechannel_base: base class for file channels.
     *
     */

    class filechannel_base {
    public:
        filechannel_base(filechannel_base const &) = delete;
        auto operator=(filechannel_base const &) -> filechannel_base & = delete;

    protected:
        using value_type = std::byte;

        filechannel_base(filechannel_base &&) noexcept = default;
        auto operator=(filechannel_base &&) noexcept
            -> filechannel_base & = default;

        /*
         * Test if this channel has been opened.
         */
        [[nodiscard]] auto is_open() const noexcept -> bool
        {
            return static_cast<bool>(cb);
        }

        [[nodiscard]] auto async_close(std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            SK_CHECK(is_open(),
                     "attempting to close a stream which is not open");

            auto tmp = std::move(cb);

            // Destroy the iocb.
            if (auto ret = co_await iocore::async_iocb_close(tmp, token); !ret)
                co_return make_unexpected(ret.error());

            co_return {};
        }

        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>
        {
            return wait(async_close());
        }

        [[nodiscard]] auto async_base_open(std::filesystem::path const &path,
                                           fileflag::flagset flags,
                                           std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            if (is_open())
                co_return make_unexpected(error::channel_already_open);

            int open_flags = 0;

            if (!_make_flags(flags, &open_flags))
                co_return make_unexpected(error::filechannel_invalid_flags);

            auto native_path = path.native();
            if (native_path.find('\0') != decltype(native_path)::npos)
                co_return make_unexpected(make_error(ENOENT));

            auto ioh = co_await iocore::async_iocb_open(
                token, native_path.c_str(), open_flags, 0777);

            if (!ioh)
                co_return make_unexpected(ioh.error());

            cb = std::move(*ioh);
            co_return {};
        }

        [[nodiscard]] auto base_open(std::filesystem::path const &path,
                                     fileflag::flagset flags) noexcept
            -> expected<void, std::error_code>
        {
            return wait(async_base_open(path, flags));
        }

        [[nodiscard]] static auto _make_flags(fileflag::flagset flags,
                                              int *open_flags) noexcept -> bool
        {
            *open_flags = 0;

            // Must specify either read or write.
            if (!any_set(flags, fileflags::read | fileflags::write))
                return false;

            // Read access only
            if (is_set(flags, fileflags::read) &&
                !is_set(flags, fileflags::write)) {
                // These flags are not valid for reading.
                if (any_set(flags,
                            fileflags::trunc | fileflags::append |
                                fileflags::create_new))
                    return false;

                *open_flags = O_RDONLY;
                return true;
            }

            // Write access or read-write access
            if (is_set(flags, fileflags::write)) {
                // Must specify either create_new or open_existing (or both).
                if (!any_set(flags,
                             fileflags::create_new | fileflags::open_existing))
                    return false;

                if (is_set(flags, fileflags::read))
                    *open_flags = O_RDWR;
                else
                    *open_flags = O_WRONLY;

                // Must create a new file.
                if (is_set(flags, fileflags::create_new) &&
                    !is_set(flags, fileflags::open_existing))
                    *open_flags |= O_CREAT | O_EXCL;
                // Can create a new file or open an existing one.
                else if (is_set(flags, fileflags::create_new) &&
                         is_set(flags, fileflags::open_existing)) {
                    if (is_set(flags, fileflags::trunc))
                        *open_flags |= O_CREAT | O_TRUNC;
                    else
                        *open_flags |= O_CREAT;
                    // Can only open an existing file.
                } else if (!is_set(flags, fileflags::create_new) &&
                           is_set(flags, fileflags::open_existing)) {
                    if (is_set(flags, fileflags::trunc))
                        *open_flags |= O_TRUNC;
                    // else
                    //    *open_flags |= 0;
                }

                return true;
            }

            return false;
        }

        filechannel_base() = default;

        ~filechannel_base()
        {
            if (is_open()) {
                SK_TRACE(
                    "filechannel_base[{}]: destructing but iocb is still open",
                    static_cast<void *>(this));

                auto reactor = weak_reactor_handle::get();
                auto *xer = reactor->get_system_executor();
                wait(co_detach(
                    [cb = this->cb]() mutable -> task<void> {
                        std::stop_token token;
                        co_await iocore::async_iocb_close(cb, token);
                    }(),
                    xer));
            }
        }

        iocore::iocb_handle cb;
    };

    /*************************************************************************
     *
     * dafilechannel_base: base class for direct access file channels.
     *
     */

    class dafilechannel_base : protected filechannel_base {
    public:
        dafilechannel_base(dafilechannel_base const &) = delete;
        auto operator=(dafilechannel_base const &)
            -> dafilechannel_base & = delete;

    protected:
        using value_type = std::byte;

        dafilechannel_base(dafilechannel_base &&) noexcept = default;
        auto operator=(dafilechannel_base &&) noexcept
            -> dafilechannel_base & = default;

        [[nodiscard]] auto async_da_open(std::filesystem::path const &path,
                                         fileflag::flagset flags) noexcept
            -> task<expected<void, std::error_code>>
        {
            return async_base_open(path, flags);
        }

        [[nodiscard]] auto da_open(std::filesystem::path const &path,
                                   fileflag::flagset flags) noexcept
            -> expected<void, std::error_code>
        {
            return base_open(path, flags);
        }

        /*
         * Read data.
         */
        [[nodiscard]] auto
        async_read_some_at(io_offset_t loc,
                           std::span<value_type> buf,
                           std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to read on a closed channel");

            auto ret = co_await iocore::async_iocb_pread(
                cb,
                token,
                buf.data(),
                buf.size(),
                sk::detail::truncate<off_t>(loc));

            if (!ret)
                co_return make_unexpected(ret.error());

            if (*ret == 0)
                co_return make_unexpected(sk::error::end_of_file);

            co_return *ret;
        }

        [[nodiscard]] auto read_some_at(io_offset_t loc,
                                        std::span<value_type> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_read_some_at(loc, buf));
        }

        /*
         * Write data.
         */
        [[nodiscard]] auto
        async_write_some_at(io_offset_t loc,
                            std::span<value_type const> buf,
                            std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to read on a closed channel");

            auto ret = co_await iocore::async_iocb_pwrite(
                cb,
                token,
                buf.data(),
                buf.size(),
                sk::detail::truncate<off_t>(loc));

            if (!ret)
                co_return make_unexpected(ret.error());

            co_return ret;
        }

        [[nodiscard]] auto
        write_some_at(io_offset_t loc, std::span<value_type const> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_write_some_at(loc, buf));
        }

        dafilechannel_base() = default;
        ~dafilechannel_base() = default;
    };

    /*************************************************************************
     *
     * seqfilechannel_base: base class for sequential access file channels.
     *
     */

    class seqfilechannel_base : protected filechannel_base {
    public:
        seqfilechannel_base(seqfilechannel_base const &) = delete;
        auto operator=(seqfilechannel_base const &)
            -> seqfilechannel_base & = delete;

    protected:
        using value_type = std::byte;

        seqfilechannel_base(seqfilechannel_base &&) noexcept = default;
        auto operator=(seqfilechannel_base &&) noexcept
            -> seqfilechannel_base & = default;

        [[nodiscard]] auto async_seq_open(std::filesystem::path const &path,
                                          fileflag::flagset flags,
                                          std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            return async_base_open(path, flags, token);
        }

        [[nodiscard]] auto seq_open(std::filesystem::path const &path,
                                    fileflag::flagset flags) noexcept
            -> expected<void, std::error_code>
        {
            return base_open(path, flags);
        }

        /*
         * Read data.
         */
        [[nodiscard]] auto async_read_some(std::span<value_type> buf,
                                           std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to read on a closed channel");

            auto ret = co_await iocore::async_iocb_read(
                cb, token, buf.data(), buf.size());

            if (!ret)
                co_return make_unexpected(ret.error());

            if (*ret == 0)
                co_return make_unexpected(error::end_of_file);

            co_return ret;
        }

        [[nodiscard]] auto read_some(std::span<value_type> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_read_some(buf));
        }

        /*
         * Write data.
         */
        [[nodiscard]] auto async_write_some(std::span<value_type const> buf,
                                            std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to read on a closed channel");

            auto ret = co_await iocore::async_iocb_write(
                cb, token, buf.data(), buf.size());

            if (!ret)
                co_return make_unexpected(get_errno());

            co_return ret;
        }

        [[nodiscard]] auto write_some(std::span<value_type const> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_write_some(buf));
        }

        seqfilechannel_base() = default;
        ~seqfilechannel_base() = default;
    };

} // namespace sk::posix::detail

#endif // SK_POSIX_DETAIL_FILECHANNEL_BASE_HXX
