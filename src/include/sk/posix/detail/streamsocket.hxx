/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_NET_DETAIL_POSIX_STREAMSOCKET_HXX_INCLUDED
#define SK_NET_DETAIL_POSIX_STREAMSOCKET_HXX_INCLUDED

#include <sys/types.h>
#include <sys/socket.h>

#include <cstddef>

#include <sk/async_invoke.hxx>
#include <sk/channel/concepts.hxx>
#include <sk/channel/error.hxx>
#include <sk/detail/safeint.hxx>
#include <sk/expected.hxx>
#include <sk/net/address.hxx>
#include <sk/posix/error.hxx>
#include <sk/posix/fd.hxx>
#include <sk/reactor.hxx>
#include <sk/task.hxx>

namespace sk::posix::detail {

    template <int type, int protocol>
    class streamsocket {
    protected:
        iocore::iocb_handle cb;

        streamsocket() = default;

        explicit streamsocket(iocore::iocb_handle &&cb_) : cb(std::move(cb_)) {}

        streamsocket(streamsocket &&) noexcept = default;

        auto operator=(streamsocket &&) noexcept -> streamsocket & = default;

        ~streamsocket()
        {
            if (is_open()) {
                SK_TRACE("streamsocket[{}]: destructing but iocb is still open",
                         static_cast<void *>(this));

                auto reactor = weak_reactor_handle::get();
                auto *xer = reactor->get_system_executor();
                wait(co_detach(
                    [cb = this->cb]() mutable -> task<void> {
                        std::stop_token token;
                        co_await iocore::async_iocb_close(cb, token);
                    }(),
                    xer));
            }
        }

        [[nodiscard]] auto _async_connect(int af,
                                          sockaddr const *addr,
                                          socklen_t addrlen,
                                          std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            SK_CHECK(!is_open(), "attempt to re-connect an open channel");

            auto sock = ::socket(af, type, protocol);

            if (sock == -1)
                co_return make_unexpected(sk::posix::get_errno());

            auto ioh = iocore::create_iocb(sock);
            if (!ioh) {
                ::close(sock);
                co_return make_unexpected(ioh.error());
            }

            auto ret =
                co_await iocore::async_iocb_connect(*ioh, token, addr, addrlen);

            if (!ret)
                co_return make_unexpected(ret.error());

            cb = std::move(*ioh);
            co_return {};
        }

        [[nodiscard]] auto
        _connect(int af, sockaddr const *addr, socklen_t addrlen) noexcept
            -> expected<void, std::error_code>
        {
            return wait(_async_connect(af, addr, addrlen));
        }

    public:
        using value_type = std::byte;

        streamsocket(streamsocket const &) = delete;
        auto operator=(streamsocket const &) -> streamsocket & = delete;

        [[nodiscard]] auto is_open() const noexcept -> bool
        {
            return static_cast<bool>(cb);
        }

        [[nodiscard]] auto async_read_some(std::span<value_type> buf,
                                           std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to read on a closed channel");

            auto bytes_read = co_await iocore::async_iocb_recv(
                cb, token, buf.data(), buf.size(), 0);

            if (!bytes_read)
                co_return make_unexpected(bytes_read.error());

            // 0 bytes = client went away
            if (*bytes_read == 0)
                co_return make_unexpected(error::end_of_file);

            co_return *bytes_read;
        }

        [[nodiscard]] auto read_some(std::span<value_type> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_read_some(buf));
        }

        [[nodiscard]] auto async_write_some(std::span<value_type const> buf,
                                            std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>
        {
            SK_CHECK(is_open(), "attempt to write on a closed channel");

            auto bytes_read = co_await iocore::async_iocb_send(
                cb, token, buf.data(), buf.size(), 0);

            if (!bytes_read)
                co_return make_unexpected(bytes_read.error());

            // 0 bytes = client went away
            if (*bytes_read == 0)
                co_return make_unexpected(sk::error::end_of_file);

            co_return *bytes_read;
        }

        [[nodiscard]] auto write_some(std::span<value_type const> buf) noexcept
            -> expected<io_size_t, std::error_code>
        {
            return wait(async_write_some(buf));
        }

        [[nodiscard]] auto async_close(std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            SK_CHECK(is_open(),
                     "attempting to close a socket which is not open");

            auto tmp = std::move(cb);

            // Destroy the iocb.
            if (auto ret = co_await iocore::async_iocb_close(tmp, token); !ret)
                co_return make_unexpected(ret.error());

            co_return {};
        }

        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>
        {
            return wait(async_close());
        }
    };

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    class streamsocketserver {
    protected:
        iocore::iocb_handle cb;

        // address_family is only used on Win32
        explicit streamsocketserver(iocore::iocb_handle &&cb_,
                                    int /*address_family*/) noexcept
            : cb(cb_)
        {
            SK_TRACE("streamsocketserver[{}]: cb<{}> construct",
                     static_cast<void *>(this),
                     static_cast<void *>(cb.get()));
        }

        streamsocketserver(streamsocketserver &&) noexcept = default;
        auto operator=(streamsocketserver &&) noexcept
            -> streamsocketserver & = default;

        ~streamsocketserver()
        {
            SK_TRACE("streamsocketserver[{}]: cb<{}> destruct",
                     static_cast<void *>(this),
                     static_cast<void *>(cb.get()));

            if (is_open()) {
                SK_TRACE("streamsocketserver[{}]: destructing but iocb is "
                         "still open",
                         static_cast<void *>(this));

                auto reactor = weak_reactor_handle::get();
                auto *xer = reactor->get_system_executor();
                wait(co_detach(
                    [cb = this->cb]() mutable -> task<void> {
                        std::stop_token token;
                        co_await iocore::async_iocb_close(cb, token);
                    }(),
                    xer));
            }
        }

        [[nodiscard]] static auto
        _listen(int af, sockaddr const *addr, socklen_t addrlen) noexcept
            -> expected<server_type, std::error_code>
        {
            SK_TRACE("streamsocketserver: listen");

            int listener = ::socket(af, type, protocol);

            if (listener == -1) {
                SK_TRACE("streamsocketserver: listen failed {}", errno);
                return make_unexpected(sk::posix::get_errno());
            }

            unique_fd listener_(listener);

#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
            if (af != AF_UNIX) {
#endif
                int one = 1;
                int ret = ::setsockopt(
                    listener,
                    SOL_SOCKET,
                    SO_REUSEADDR,
                    // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
                    reinterpret_cast<char const *>(&one),
                    sizeof(one));
                if (ret != 0) {
                    SK_TRACE("streamsocketserver: setsockopt failed {}", errno);
                    return make_unexpected(sk::posix::get_errno());
                }
#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
            }
#endif

            auto ret = ::bind(listener, addr, addrlen);
            if (ret == -1) {
                SK_TRACE("streamsocketserver: bind failed {}", errno);
                return make_unexpected(sk::posix::get_errno());
            }

            ret = ::listen(listener, SOMAXCONN);
            if (ret == -1) {
                SK_TRACE("streamsocketserver: listen failed {}", errno);
                return make_unexpected(sk::posix::get_errno());
            }

            auto ioh = iocore::create_iocb(listener);
            if (!ioh) {
                SK_TRACE("streamsocketserver: create_iocb failed {}",
                         ioh.error().message());
                return make_unexpected(ioh.error());
            }

            listener_.release();
            SK_TRACE("streamsocketserver: ok, fd={}, iocb={}",
                     (*ioh)->fd,
                     static_cast<void *>(ioh->get()));
            return server_type{std::move(*ioh), af};
        }

    public:
        using value_type = std::byte;

        streamsocketserver(streamsocketserver const &) = delete;
        auto operator=(streamsocketserver const &)
            -> streamsocketserver & = delete;

        [[nodiscard]] auto is_open() const noexcept -> bool
        {
            return static_cast<bool>(cb);
        }

        [[nodiscard]] auto async_accept(std::stop_token token = {}) noexcept
            -> task<expected<channel_type, std::error_code>>
        {
            SK_TRACE("streamsocketserver[{}]: cb<{}> accept",
                     static_cast<void *>(this),
                     static_cast<void *>(cb.get()));

            auto client =
                co_await iocore::async_iocb_accept(cb, token, nullptr, nullptr);
            if (!client)
                co_return make_unexpected(client.error());

            auto ioh = iocore::create_iocb(*client);
            if (!ioh) {
                ::close(*client);
                co_return make_unexpected(ioh.error());
            }

            co_return channel_type{std::move(*ioh)};
        }

        [[nodiscard]] auto accept() noexcept
            -> expected<channel_type, std::error_code>
        {
            return wait(async_accept());
        }

        [[nodiscard]] auto async_close(std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>
        {
            SK_TRACE("streamsocketserver[{}]: cb<{}> close",
                     static_cast<void *>(this),
                     static_cast<void *>(cb.get()));

            SK_CHECK(is_open(),
                     "attempting to close a socket which is not open");

            auto tmp = std::move(cb);

            // Destroy the iocb.
            if (auto ret = co_await iocore::async_iocb_close(tmp, token); !ret)
                co_return make_unexpected(ret.error());

            co_return {};
        }

        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>
        {
            return wait(async_close());
        }
    };

} // namespace sk::posix::detail

#endif // SK_NET_DETAIL_POSIX_STREAMSOCKET_HXX_INCLUDED
