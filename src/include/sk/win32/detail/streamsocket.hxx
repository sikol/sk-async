/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_WIN32_DETAIL_STREAMSOCKET_HXX_INCLUDED
#define SK_WIN32_DETAIL_STREAMSOCKET_HXX_INCLUDED

#include <cstddef>
#include <stop_token>

#include <sk/async_invoke.hxx>
#include <sk/channel/concepts.hxx>
#include <sk/co_detach.hxx>
#include <sk/detail/safeint.hxx>
#include <sk/expected.hxx>
#include <sk/net/address.hxx>
#include <sk/task.hxx>
#include <sk/win32/async_api.hxx>
#include <sk/win32/handle.hxx>

#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
#    include <afunix.h>
#endif

namespace sk::win32::detail {

    template <int type, int protocol>
    struct streamsocket {
    protected:
        iocb_handle cb;

        streamsocket() noexcept = default;

        explicit streamsocket(iocb_handle &&sock) noexcept;

        streamsocket(streamsocket &&) noexcept = default;
        auto operator=(streamsocket &&) noexcept -> streamsocket & = default;
        ~streamsocket();

        [[nodiscard]] auto _async_connect(int af,
                                          sockaddr const *addr,
                                          socklen_t addrlen,
                                          std::stop_token token = {}) noexcept
            -> task<expected<void, std::error_code>>;

        [[nodiscard]] auto
        _connect(int af, sockaddr const *addr, socklen_t addrlen) noexcept
            -> expected<void, std::error_code>;

    public:
        using value_type = std::byte;
        using native_handle_type = unique_socket;

        streamsocket(streamsocket const &) = delete;
        auto operator=(streamsocket const &) -> streamsocket & = delete;

        [[nodiscard]] auto is_open() const noexcept -> bool;

        [[nodiscard]] auto async_read_some(std::span<value_type> buf,
                                           std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>;

        [[nodiscard]] auto read_some(std::span<value_type> buf) noexcept
            -> expected<io_size_t, std::error_code>;

        [[nodiscard]] auto async_write_some(std::span<value_type const> buf,
                                            std::stop_token token = {}) noexcept
            -> task<expected<io_size_t, std::error_code>>;

        [[nodiscard]] auto write_some(std::span<value_type const> buf) noexcept
            -> expected<io_size_t, std::error_code>;

        [[nodiscard]] auto async_close() noexcept
            -> task<expected<void, std::error_code>>;

        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>;
    };

    /*************************************************************************
     * streamsocket::streamsocket()
     */

    template <int type, int protocol>
    streamsocket<type, protocol>::streamsocket(iocb_handle &&sock) noexcept
        : cb(std::move(sock))
    {
    }

    /*************************************************************************
     * streamsocket::~streamsocket()
     */

    template <int type, int protocol>
    streamsocket<type, protocol>::~streamsocket()
    {
        if (is_open()) {
            SK_TRACE("streamsocket[{}]: destructing but iocb is still open",
                     static_cast<void *>(this));

            auto reactor = weak_reactor_handle::get();
            auto *xer = reactor->get_system_executor();
            wait(co_detach(
                [cb = this->cb]() mutable -> task<void> {
                    co_await iocore::async_iocb_close(cb);
                }(),
                xer));
        }
    }

    /*************************************************************************
     * streamsocket::is_open()
     */

    template <int type, int protocol>
    auto streamsocket<type, protocol>::is_open() const noexcept -> bool
    {
        return static_cast<bool>(cb);
    }

    /*************************************************************************
     * streamsocket::close()
     */
    template <int type, int protocol>
    auto streamsocket<type, protocol>::close() noexcept
        -> expected<void, std::error_code>
    {
        return wait(async_close());
    }

    /*************************************************************************
     * streamsocket::async_close()
     */
    template <int type, int protocol>
    auto streamsocket<type, protocol>::async_close() noexcept
        -> task<expected<void, std::error_code>>
    {
        SK_CHECK(is_open(), "attempting to close a stream which is not open");

        unique_handle handle(cb->hdl);

        // Destroy the iocb.
        co_await iocore::async_iocb_close(cb);

        cb.reset();

        // Close the handle.
        auto ret = handle.close();
        if (!ret)
            co_return make_unexpected(ret.error());

        co_return {};
    }

    /*************************************************************************
     * streamsocket::async_connect()
     */
    template <int type, int protocol>
    auto
    streamsocket<type, protocol>::_async_connect(int af,
                                                 sockaddr const *addr,
                                                 socklen_t addrlen,
                                                 std::stop_token token) noexcept
        -> task<expected<void, std::error_code>>
    {
        SK_CHECK(!is_open(), "attempt to re-connect an open channel");

        auto sock = ::WSASocketW(
            af, SOCK_STREAM, protocol, nullptr, 0, WSA_FLAG_OVERLAPPED);

        if (sock == INVALID_SOCKET)
            co_return make_unexpected(win32::get_last_winsock_error());

        struct socket_deleter {
            auto operator()(void *s)
            {
                ::closesocket(handle_cast<SOCKET>(s));
            }
        };

        std::unique_ptr<void, socket_deleter> sock_(handle_cast<HANDLE>(sock));

        static GUID connectex_guid = WSAID_CONNECTEX;
        LPFN_CONNECTEX ConnectEx{};
        DWORD n{};

        auto ret = ::WSAIoctl(sock,
                              SIO_GET_EXTENSION_FUNCTION_POINTER,
                              (void *)&connectex_guid,
                              sizeof(connectex_guid),
                              (void *)&ConnectEx,
                              sizeof(ConnectEx),
                              &n,
                              nullptr,
                              nullptr);

        if (ret != 0)
            co_return make_unexpected(sk::error::winsock_no_connectex);

        // Winsock requires binding the socket before we can use ConnectEx().
        // Bind it to the all-zeroes address.
        sockaddr_storage zero_address{};
        zero_address.ss_family = static_cast<ADDRESS_FAMILY>(af);

        if (::bind(sock,
                   net::detail::sockaddr_cast<sockaddr const *>(&zero_address),
                   sizeof(zero_address)) != 0)
            co_return make_unexpected(win32::get_last_winsock_error());

        auto ioh = iocore::create_iocb(handle_cast<HANDLE>(sock));
        if (!ioh)
            co_return make_unexpected(ioh.error());

        auto connstatus = co_await iocore::async_iocb_invoke_overlapped(
            *ioh,
            std::move(token),
            [&](HANDLE hdl, iocore::iocb::io *io) -> DWORD {
                auto ret = ConnectEx(handle_cast<SOCKET>(hdl),
                                     addr,
                                     addrlen,
                                     nullptr,
                                     0,
                                     &io->bytes_transferred,
                                     io);

                if (ret == TRUE)
                    return NO_ERROR;

                return ::WSAGetLastError();
            });

        if (!connstatus)
            co_return make_unexpected(connstatus.error());

        cb = std::move(*ioh);
        sock_.release();
        co_return {};
    }

    /*************************************************************************
     * streamsocket::connect()
     */
    template <int type, int protocol>
    auto streamsocket<type, protocol>::_connect(int af,
                                                sockaddr const *addr,
                                                socklen_t addrlen) noexcept
        -> expected<void, std::error_code>
    {
        return wait(_async_connect(af, addr, addrlen));
    }

    /*************************************************************************
     * streamsocket::async_read_some()
     */

    template <int type, int protocol>
    auto streamsocket<type, protocol>::async_read_some(
        std::span<value_type> buf, std::stop_token token) noexcept
        -> task<expected<io_size_t, std::error_code>>
    {
        SK_CHECK(is_open(), "attempt to read on a closed channel");

        auto bufsize = sk::detail::truncate<DWORD>(buf.size());
        auto nbytes = co_await iocore::async_iocb_invoke_overlapped(
            cb,
            std::move(token),
            [&](HANDLE hdl, iocore::iocb::io *io) -> DWORD {
                auto ret = ::ReadFile(
                    hdl, buf.data(), bufsize, &io->bytes_transferred, io);

                if (ret == TRUE)
                    return NO_ERROR;

                return ::GetLastError();
            });

        if (!nbytes)
            co_return make_unexpected(nbytes.error());

        // 0 bytes = client went away
        if (*nbytes == 0)
            co_return make_unexpected(sk::error::end_of_file);

        co_return *nbytes;
    }

    /*************************************************************************
     * streamsocket::read_some()
     */

    template <int type, int protocol>
    auto
    streamsocket<type, protocol>::read_some(std::span<value_type> buf) noexcept
        -> expected<io_size_t, std::error_code>
    {
        return wait(async_read_some(buf));
    }

    /*************************************************************************
     * streamsocket::async_write_some()
     */

    template <int type, int protocol>
    auto streamsocket<type, protocol>::async_write_some(
        std::span<value_type const> buf, std::stop_token token) noexcept
        -> task<expected<io_size_t, std::error_code>>
    {
        SK_CHECK(is_open(), "attempt to write on a closed channel");

        auto bufsize = sk::detail::truncate<DWORD>(buf.size());
        auto nbytes = co_await iocore::async_iocb_invoke_overlapped(
            cb,
            std::move(token),
            [&](HANDLE hdl, iocore::iocb::io *io) -> DWORD {
                auto ret = ::WriteFile(
                    hdl, buf.data(), bufsize, &io->bytes_transferred, io);

                if (ret == TRUE)
                    return NO_ERROR;

                return ::GetLastError();
            });

        if (!nbytes)
            co_return make_unexpected(nbytes.error());

        co_return *nbytes;
    }

    /*************************************************************************
     * streamsocket::write_some()
     */

    template <int type, int protocol>
    auto streamsocket<type, protocol>::write_some(
        std::span<value_type const> buf) noexcept
        -> expected<io_size_t, std::error_code>
    {
        return wait(async_write_some(buf));
    }

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    class streamsocketserver {
        iocb_handle cb;

        // On Windows, we need to create a new socket to accept into, which
        // means we need to know the address family we're accepting for.
        int _address_family{AF_UNSPEC};

    protected:
        streamsocketserver(iocb_handle &&ioh, int address_family) noexcept;
        streamsocketserver(streamsocketserver &&) noexcept = default;
        auto operator=(streamsocketserver &&) noexcept
            -> streamsocketserver & = default;
        ~streamsocketserver();

        [[nodiscard]] static auto
        _listen(int af, sockaddr const *addr, socklen_t addrlen) noexcept
            -> expected<server_type, std::error_code>;

    public:
        using value_type = std::byte;
        using native_handle_type = unique_socket;

        streamsocketserver(streamsocketserver const &) = delete;
        auto operator=(streamsocketserver const &)
            -> streamsocketserver & = delete;

        [[nodiscard]] auto is_open() const noexcept -> bool;

        [[nodiscard]] auto async_accept(std::stop_token token = {}) noexcept
            -> task<expected<channel_type, std::error_code>>;

        [[nodiscard]] auto accept() noexcept
            -> expected<channel_type, std::error_code>;

        [[nodiscard]] auto async_close() noexcept
            -> task<expected<void, std::error_code>>;

        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>;
    };

    /*************************************************************************
     * streamsocketserver::streamsocketserver()
     */

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    streamsocketserver<server_type, channel_type, type, protocol>::
        streamsocketserver(iocb_handle &&ioh, int address_family) noexcept
        : cb(std::move(ioh)), _address_family(address_family)
    {
    }

    /*************************************************************************
     * streamsocketserver::~streamsocketserver()
     */

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    streamsocketserver<server_type, channel_type, type, protocol>::
        ~streamsocketserver()
    {
        if (is_open()) {
            SK_TRACE(
                "streamsocketserver[{}]: destructing but iocb is still open",
                static_cast<void *>(this));

            auto reactor = weak_reactor_handle::get();
            auto *xer = reactor->get_system_executor();
            wait(co_detach(
                [cb = this->cb]() mutable -> task<void> {
                    co_await iocore::async_iocb_close(cb);
                }(),
                xer));
        }
    }

    /*************************************************************************
     * streamsocketserver::is_open()
     */

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto
    streamsocketserver<server_type, channel_type, type, protocol>::is_open()
        const noexcept -> bool
    {
        return static_cast<bool>(cb);
    }

    /*************************************************************************
     * streamsocketserver::listen}()
     */

    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto streamsocketserver<server_type, channel_type, type, protocol>::_listen(
        int af, sockaddr const *addr, socklen_t addrlen) noexcept
        -> expected<server_type, std::error_code>
    {
        SOCKET listener = ::socket(af, type, protocol);

        if (listener == INVALID_SOCKET)
            return make_unexpected(win32::get_last_winsock_error());

        unique_socket listener_(listener);

        // Setting SO_REUSEADDR on an AF_UNIX socket is pointless, but on
        // Windows it returns an error.
#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
        if (af != AF_UNIX) {
#endif
            DWORD one = 1;
            int sret = ::setsockopt(
                listener,
                SOL_SOCKET,
                SO_REUSEADDR,
                // NOLINTNEXTLINE(cppcoreguidelines-pro-type-reinterpret-cast)
                reinterpret_cast<char const *>(&one),
                sizeof(one));
            if (sret == SOCKET_ERROR)
                return make_unexpected(win32::get_last_winsock_error());
#ifdef SK_CIO_PLATFORM_HAS_AF_UNIX
        }
#endif

        int ret = ::bind(listener, addr, addrlen);
        if (ret == SOCKET_ERROR)
            return make_unexpected(win32::get_last_error());

        ret = ::listen(listener, SOMAXCONN);
        if (ret == SOCKET_ERROR)
            return make_unexpected(win32::get_last_error());

        auto ioh = iocore::create_iocb(handle_cast<HANDLE>(listener));
        if (!ioh)
            return make_unexpected(win32::get_last_error());

        listener_.release();
        return server_type(std::move(*ioh), af);
    }

    /*************************************************************************
     * streamsocketserver::close()
     */
    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto streamsocketserver<server_type, channel_type, type, protocol>::
        close() noexcept -> expected<void, std::error_code>
    {
        return wait(async_close());
    }

    /*************************************************************************
     * streamsocketserver::async_close()
     */
    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto streamsocketserver<server_type, channel_type, type, protocol>::
        async_close() noexcept -> task<expected<void, std::error_code>>
    {
        SK_CHECK(is_open(), "attempting to close a stream which is not open");

        SK_TRACE("streamsocketserver[{}]: async_close: enter",
                 static_cast<void *>(this));

        unique_handle handle(cb->hdl);

        // Destroy the iocb.
        co_await iocore::async_iocb_close(cb);

        SK_TRACE(
            "streamsocketserver[{}]: async_close: async_iocb_close complete",
            static_cast<void *>(this));

        cb.reset();

        SK_TRACE("streamsocketserver[{}]: async_close: closing the handle",
                 static_cast<void *>(this));

        // Close the handle.
        auto ret = handle.close();
        if (!ret) {
            SK_TRACE("streamsocketserver[{}]: async_close: return with error",
                     static_cast<void *>(this));
            co_return make_unexpected(ret.error());
        }

        SK_TRACE("streamsocketserver[{}]: async_close: return success",
                 static_cast<void *>(this));

        co_return {};
    }

    /*************************************************************************
     * streamsocketserver::async_accept()
     */
    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto
    streamsocketserver<server_type, channel_type, type, protocol>::async_accept(
        std::stop_token token) noexcept
        -> task<expected<channel_type, std::error_code>>
    {
        auto client_socket = ::socket(_address_family, type, protocol);

        if (client_socket == INVALID_SOCKET)
            co_return make_unexpected(win32::get_last_winsock_error());

        unique_socket client_socket_(client_socket);

        LPFN_ACCEPTEX AcceptEx{};
        static GUID accpectex_guid = WSAID_ACCEPTEX;
        DWORD n = 0;

        auto ret = ::WSAIoctl(client_socket,
                              SIO_GET_EXTENSION_FUNCTION_POINTER,
                              (void *)&accpectex_guid,
                              sizeof(accpectex_guid),
                              (void *)&AcceptEx,
                              sizeof(AcceptEx),
                              &n,
                              nullptr,
                              nullptr);

        if (ret == SOCKET_ERROR)
            co_return make_unexpected(sk::error::winsock_no_acceptex);

        auto ioh = iocore::create_iocb(handle_cast<HANDLE>(client_socket));
        if (!ioh)
            co_return make_unexpected(ioh.error());

        // This has to be provided even though we don't use it.
        // Windows requires 16 bytes + the address size for local and remote.
        static constexpr std::size_t junkpad = 16;
        std::array<char, (junkpad + sizeof(sockaddr_storage)) * 2> junk{};

        auto acceptstatus = co_await iocore::async_iocb_invoke_overlapped(
            cb,
            std::move(token),
            [&](HANDLE hdl, iocore::iocb::io *io) -> DWORD {
                auto ret = AcceptEx(handle_cast<SOCKET>(hdl),
                                    handle_cast<SOCKET>((*ioh)->hdl),
                                    junk.data(),
                                    0,
                                    sizeof(sockaddr_storage) + junkpad,
                                    sizeof(sockaddr_storage) + junkpad,
                                    &io->bytes_transferred,
                                    io);

                if (ret == TRUE)
                    return NO_ERROR;

                return ::WSAGetLastError();
            });

        if (!acceptstatus)
            co_return make_unexpected(acceptstatus.error());

        client_socket_.release();
        co_return channel_type{std::move(*ioh)};
    }

    /*************************************************************************
     * streamsocketserver::async_accept()
     */
    template <typename server_type,
              seqchannel channel_type,
              int type,
              int protocol>
    auto streamsocketserver<server_type, channel_type, type, protocol>::
        accept() noexcept -> expected<channel_type, std::error_code>
    {
        return wait(async_accept());
    }

} // namespace sk::win32::detail

#endif // SK_WIN32_DETAIL_STREAMSOCKET_HXX_INCLUDED
