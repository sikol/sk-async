/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#ifndef SK_WIN32_HANDLE_HXX_INCLUDED
#define SK_WIN32_HANDLE_HXX_INCLUDED

#include <system_error>

#include <sk/check.hxx>
#include <sk/expected.hxx>
#include <sk/win32/error.hxx>
#include <sk/win32/windows.hxx>

namespace sk::win32 {

    /*************************************************************************
     *
     * RAII wrapper for Windows handles.
     *
     * unique_handle: this handle can only have one owner.  The handle is not
     * copyable, but it can be moved.
     */

    // NOLINTNEXTLINE
#define SK_INVALID_HANDLE_VALUE                                                \
    (reinterpret_cast<void *>(static_cast<uintptr_t>(-1)))
    // Would be nicer to do it like this, but casts to void* cannot be
    // constexpr.
    // static constexpr HANDLE invalid_handle_value = std::bit_cast<void
    // *>(static_cast<uintptr_t>(-1));

    struct unique_handle {
        // Create an empty unique_handle.
        unique_handle() noexcept
            : _is_valid(false), _native_handle(SK_INVALID_HANDLE_VALUE)
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
        }

        // Create a unique_handle from a native handle.
        explicit unique_handle(HANDLE handle_value_) noexcept
            : _is_valid(true), _native_handle(handle_value_)
        {
            sk::detail::check(handle_value_ != nullptr &&
                                  handle_value_ != SK_INVALID_HANDLE_VALUE,
                              "unique_handle: creating invalid handle");

            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
        }

        // Move construction.
        unique_handle(unique_handle &&other) noexcept
            : _is_valid(std::exchange(other._is_valid, false)),
              _native_handle(
                  std::exchange(other._native_handle, SK_INVALID_HANDLE_VALUE))
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
        }

        auto operator=(unique_handle &&other) noexcept -> unique_handle &
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
            if (this != &other) {
                _is_valid = std::exchange(other._is_valid, false);
                _native_handle = std::exchange(other._native_handle,
                                               SK_INVALID_HANDLE_VALUE);
            }

            return *this;
        }

        // Destructor.
        ~unique_handle()
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
            // XXX - should decide what to do here if the close fails.
            // Destructing an open socket is a bad idea and should probably
            // abort, but we would like to be exception-safe if possible.
            if (_is_valid)
                std::ignore = close();
        }

        // Not copyable.
        unique_handle(unique_handle const &) = delete;
        auto operator=(unique_handle const &) -> unique_handle & = delete;

        // Close the handle.
        [[nodiscard]] auto close() noexcept -> expected<void, std::error_code>
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
            if (!_is_valid)
                return {};

            _is_valid = false;
            if (::CloseHandle(_native_handle) == TRUE) {
                _native_handle = SK_INVALID_HANDLE_VALUE;
                return {};
            }

            return make_unexpected(win32::get_last_error());
        }

        // Test if we have a valid handle.
        [[nodiscard]] operator bool() const noexcept
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
            return _is_valid;
        }

        // Return the Win32 handle.
        [[nodiscard]] auto native_handle() -> HANDLE
        {
            sk::detail::check(_is_valid || _native_handle == SK_INVALID_HANDLE_VALUE,
                              "unique_handle: bad state");
            sk::detail::check(_is_valid, "attempt to access invalid handle");
            return _native_handle;
        }

    private:
        bool _is_valid = false;
        HANDLE _native_handle = SK_INVALID_HANDLE_VALUE;
    };

    /*************************************************************************
     *
     * unique_socket: a unique handle to a Winsock socket.
     */

    struct unique_socket {
        unique_socket() noexcept : _native_socket(INVALID_SOCKET) {}

        explicit unique_socket(SOCKET native_socket) noexcept
            : _native_socket(native_socket)
        {
        }

        unique_socket(unique_socket &&other) noexcept
            : _native_socket(
                  std::exchange(other._native_socket, INVALID_SOCKET))
        {
        }

        ~unique_socket() noexcept
        {
            // XXX - should decide what to do here if the close fails.
            // Destructing an open socket is a bad idea and should probably
            // abort, but we would like to be exception-safe if possible.
            std::ignore = close();
        }

        // Not copyable.
        unique_socket(unique_socket const &) = delete;
        auto operator=(unique_socket const &) -> unique_socket & = delete;

        auto operator=(unique_socket &&other) noexcept -> unique_socket &
        {
            if (this != &other)
                _native_socket =
                    std::exchange(other._native_socket, INVALID_SOCKET);

            return *this;
        }

        // Close the handle.
        [[nodiscard]] auto close() noexcept -> std::error_code
        {
            if (!*this)
                return win32::error::success;

            auto ret = ::closesocket(_native_socket);
            _native_socket = INVALID_SOCKET;

            if (ret == 0)
                return win32::error::success;
            return win32::get_last_winsock_error();
        }

        // Test if we have a valid socket.
        [[nodiscard]] operator bool() const noexcept
        {
            return _native_socket != INVALID_SOCKET;
        }

        // Return the socket.
        [[nodiscard]] auto native_socket() const -> SOCKET
        {
            sk::detail::check(*this, "attempt to access invalid socket");
            return _native_socket;
        }

    private:
        SOCKET _native_socket;
    };

    template <typename To, typename From>
    inline auto handle_cast(From from) -> To = delete;

    template <>
    inline auto handle_cast<HANDLE>(SOCKET from) -> HANDLE
    {
        return reinterpret_cast<HANDLE>(
            from); // NOLINT(performance-no-int-to-ptr)
    }

    template <>
    inline auto handle_cast<SOCKET>(HANDLE from) -> SOCKET
    {
        return reinterpret_cast<SOCKET>(
            from); // NOLINT(performance-no-int-to-ptr)
    }

} // namespace sk::win32

#endif // SK_WIN32_HANDLE_HXX_INCLUDED
