/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <array>
#include <chrono>
#include <fstream>
#include <iostream>

#include <catch.hpp>

#include <fmt/core.h>

#include <sk/cio.hxx>

using namespace sk;
using namespace std::literals::chrono_literals;

constexpr int nthreads = 30;
constexpr int nops = 500;
constexpr auto run_for = 20s;

std::string const tcp_listen_address = "127.0.0.1";
std::uint16_t const tcp_listen_port = 5357;
std::optional<net::tcp_endpoint> tcp_listen_addr;

task<int> tcp_stress_task()
{
    std::random_device r;
    std::default_random_engine eng(r());
    std::uniform_int_distribution<io_size_t> rnd_1_50(1, 50);
    std::uniform_int_distribution<int> rnd_byte(0, 255);

    auto start = std::chrono::steady_clock::now();

    for (;;) {

        // Connect to the test host.
        net::tcpchannel chnl;
        auto ret = co_await chnl.async_connect(*tcp_listen_addr);
        if (!ret) {
            std::cerr << "stress_task: failed to connect: "
                      << ret.error().message() << "\n";
            co_return 1;
        }

        for (int i = 0; i < nops; ++i) {
            std::byte outbuf[50], inbuf[50];
            io_size_t buflen;

            // Generate random data.
            buflen = rnd_1_50(eng);
            for (io_size_t n = 0; n < buflen; ++n)
                outbuf[n] = std::byte(rnd_byte(eng));

            // std::span to work around MSVC bug
            auto wret =
                co_await async_write_all(chnl, std::span(outbuf, buflen));
            if (wret.first != buflen) {
                fmt::print(stderr, "short write: {}\n", wret.first);
                co_return 1;
            }

            auto rret = co_await async_read_all(chnl, std::span(inbuf, buflen));
            if (rret.first != buflen) {
                fmt::print(stderr, "short read: {}\n", rret.first);
                co_return 1;
            }

            if (std::memcmp(outbuf, inbuf, buflen)) {
                fmt::print(stderr, "failed compare\n");
                std::ostringstream strm;

                strm << "sent: ";
                for (io_size_t n = 0; n < buflen; ++n)
                    strm << static_cast<int>(outbuf[n]) << " ";

                strm << "\nrecv: ";
                for (io_size_t n = 0; n < buflen; ++n)
                    strm << static_cast<int>(inbuf[n]) << " ";

                strm << "\n";
                fmt::print(stderr, "{}", strm.str());
                co_return 1;
            }
        }

        auto now = std::chrono::steady_clock::now();
        if ((now - start) >= run_for)
            break;
    }

    co_return 0;
}

task<void> tcp_handle_client(net::tcpchannel client)
{
    for (;;) {
        sk::fixed_buffer<std::byte, 1024> buf;

        auto ret = co_await async_read_some(client, buf, unlimited);

        if (!ret) {
            if (ret.error() != error::end_of_file)
                fmt::print(stderr, "read err: {}\n", ret.error().message());
            co_await client.async_close();
            co_return;
        }

        auto wret = co_await async_write_some(client, buf, unlimited);
        if (!wret) {
            co_await client.async_close();
            co_return;
        }
    }
}

task<void> tcp_server_task(net::tcpserverchannel &chnl)
{
    for (;;) {
        auto client = co_await chnl.async_accept();
        if (!client) {
            fmt::print(
                stderr, "async_accept(): {}\n", client.error().message());
            co_return;
        }

        co_await co_detach(tcp_handle_client(std::move(*client)));
    }
}

auto run_tcp_stress_task(std::promise<int> &promise) -> task<void> {
  auto ret = co_await tcp_stress_task();
  promise.set_value(ret);
}

TEST_CASE("tcpchannel stress test")
{
    // Create the server channel.
    auto ep = net::make_tcp_endpoint(tcp_listen_address, tcp_listen_port);
    if (!ep) {
        fmt::print(stderr,
                   "{}:{}: {}\n",
                   tcp_listen_address,
                   tcp_listen_port,
                   ep.error().message());
        REQUIRE(false);
    }

    tcp_listen_addr = *ep;
    auto server = net::tcpserverchannel::listen(*ep);
    REQUIRE(server);

    auto reactor = get_weak_reactor_handle();
    auto *xer = reactor->get_system_executor();
    wait(co_detach(tcp_server_task(*server), xer));

    std::vector<std::promise<int>> promises(nthreads);

    for (int i = 0; i < nthreads; ++i) {
        wait(co_detach(run_tcp_stress_task(promises[i]), xer));
    }

    int errors = 0;

    for (auto &&promise : promises) {
        auto ret = promise.get_future().get();
        errors += ret;
    }

    REQUIRE(errors == 0);
}
