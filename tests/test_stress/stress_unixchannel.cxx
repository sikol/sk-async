/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <array>
#include <chrono>
#include <fstream>
#include <iostream>

#include <catch.hpp>

#include <fmt/core.h>

#include <sk/cio.hxx>

using namespace sk;
using namespace std::literals::chrono_literals;

constexpr int nthreads = 30;
constexpr int nops = 500;
constexpr auto run_for = 20s;

auto const unix_listen_address =
    std::filesystem::current_path() / "__sk_test.sock";
net::address<> unix_listen_addr;

task<int> unix_stress_task()
{
    std::random_device r;
    std::default_random_engine eng(r());
    std::uniform_int_distribution<io_size_t> rnd_1_50(1, 50);
    std::uniform_int_distribution<int> rnd_byte(0, 255);

    auto start = std::chrono::steady_clock::now();

    for (;;) {

        // Connect to the test host.
        net::unixchannel chnl;
        auto ret = co_await chnl.async_connect(unix_listen_addr);
        if (!ret) {
            std::cerr << "stress_task: failed to connect: "
                      << ret.error().message() << "\n";
            co_return 1;
        }

        for (int i = 0; i < nops; ++i) {
            std::byte outbuf[50], inbuf[50];
            io_size_t buflen;

            // Generate random data.
            buflen = rnd_1_50(eng);
            for (io_size_t n = 0; n < buflen; ++n)
                outbuf[n] = std::byte(rnd_byte(eng));

            // std::span to work around MSVC bug
            auto wret =
                co_await async_write_all(chnl, std::span(outbuf, buflen));
            if (wret.first != buflen) {
                fmt::print(stderr, "short write: {}\n", wret.first);
                co_return 1;
            }

            auto rret = co_await async_read_all(chnl, std::span(inbuf, buflen));
            if (rret.first != buflen) {
                fmt::print(stderr, "short read: {}\n", rret.first);
                co_return 1;
            }

            if (std::memcmp(outbuf, inbuf, buflen)) {
                fmt::print(stderr, "failed compare\n");
                std::ostringstream strm;

                strm << "sent: ";
                for (io_size_t n = 0; n < buflen; ++n)
                    strm << static_cast<int>(outbuf[n]) << " ";

                strm << "\nrecv: ";
                for (io_size_t n = 0; n < buflen; ++n)
                    strm << static_cast<int>(inbuf[n]) << " ";

                strm << "\n";
                fmt::print(stderr, "{}", strm.str());
                co_return 1;
            }
        }

        auto now = std::chrono::steady_clock::now();
        if ((now - start) >= run_for)
            break;
    }

    co_return 0;
}

task<void> unix_handle_client(net::unixchannel client)
{
    for (;;) {
        sk::fixed_buffer<std::byte, 1024> buf;

        auto ret = co_await async_read_some(client, buf, unlimited);

        if (!ret) {
            if (ret.error() != error::end_of_file)
                fmt::print(stderr, "read err: {}\n", ret.error().message());
            co_await client.async_close();
            co_return;
        }

        auto wret = co_await async_write_some(client, buf, unlimited);
        if (!wret) {
            co_await client.async_close();
            co_return;
        }
    }

    fmt::print(stderr, "handle_client() : return\n");
}

task<void> unix_server_task(net::unixserverchannel &chnl)
{
    for (;;) {
        auto client = co_await chnl.async_accept();

        if (!client) {
            fmt::print(
                stderr, "async_accept(): {}\n", client.error().message());
            co_return;
        }

        co_detach(unix_handle_client(std::move(*client)));
    }
}

TEST_CASE("unixchannel stress test")
{
    // Create the server channel.
    auto netaddr = net::make_unix_address(unix_listen_address);
    if (!netaddr) {
        fmt::print(stderr,
                   "{}:{}: {}\n",
                   unix_listen_address.generic_string(),
                   netaddr.error().message());
        return;
    }

    unix_listen_addr = *netaddr;

    std::ignore = std::remove(unix_listen_address.string().c_str());
    auto server = net::unixserverchannel::listen(*netaddr);
    if (!server) {
        INFO(unix_listen_address);
        INFO(server.error().message());
        REQUIRE(server);
    }

    co_detach(unix_server_task(*server));

    std::this_thread::sleep_for(1s);
    std::cerr << "starting stress tasks\n";

    std::vector<std::future<int>> futures;

    for (int i = 0; i < nthreads; ++i)
        futures.emplace_back(std::async(std::launch::async, [&]() -> int {
            return wait(unix_stress_task());
        }));

    std::cerr << "joining stress tasks\n";

    int errors = 0;

    for (auto &&future : futures) {
        auto ret = future.get();
        errors += ret;
    }

    REQUIRE(errors == 0);
}
