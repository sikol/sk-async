/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <string>

#include <catch.hpp>

#include <sk/static_vector.hxx>

#ifdef __clang__
#    pragma clang diagnostic ignored "-Wself-assign-overloaded"
#    pragma clang diagnostic ignored "-Wself-move"
#endif

using sk::static_vector;

TEST_CASE("static_vector<int> push_back")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.push_back(1);
    v.push_back(42);
    v.push_back(666);

    REQUIRE(v.size() == 3);
    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
}

TEST_CASE("static_vector<std::string> push_back")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.push_back("1");
    v.push_back("42");
    v.push_back("666");

    REQUIRE(v.size() == 3);
    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
}

TEST_CASE("static_vector<int> emplace_back")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    REQUIRE(v.size() == 3);
    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
}

TEST_CASE("static_vector<std::string> emplace_back")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    REQUIRE(v.size() == 3);
    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
}

TEST_CASE("static_vector<int> copy construct")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    static_vector<int, 3> v2(v);
    REQUIRE(v.size() == 3);
    REQUIRE(v2.size() == 3);

    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
    REQUIRE(v2[0] == 1);
    REQUIRE(v2[1] == 42);
    REQUIRE(v2[2] == 666);
}

TEST_CASE("static_vector<std::string> copy construct")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    static_vector<std::string, 3> v2(v);
    REQUIRE(v.size() == 3);
    REQUIRE(v2.size() == 3);

    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
    REQUIRE(v2[0] == "1");
    REQUIRE(v2[1] == "42");
    REQUIRE(v2[2] == "666");
}

TEST_CASE("static_vector<int> copy assign")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    static_vector<int, 3> v2;
    v2 = v;

    REQUIRE(v.size() == 3);
    REQUIRE(v2.size() == 3);

    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
    REQUIRE(v2[0] == 1);
    REQUIRE(v2[1] == 42);
    REQUIRE(v2[2] == 666);
}

TEST_CASE("static_vector<std::string> copy assign")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    static_vector<std::string, 3> v2;
    v2 = v;

    REQUIRE(v.size() == 3);
    REQUIRE(v2.size() == 3);

    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
    REQUIRE(v2[0] == "1");
    REQUIRE(v2[1] == "42");
    REQUIRE(v2[2] == "666");
}

TEST_CASE("static_vector<int> copy self-assign")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    v = v; // NOLINT

    REQUIRE(v.size() == 3);

    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
}

TEST_CASE("static_vector<std::string> copy self-assign")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    v = v; // NOLINT

    REQUIRE(v.size() == 3);

    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
}

TEST_CASE("static_vector<int> move self-assign")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    v = std::move(v); // NOLINT

    REQUIRE(v.size() == 3); // NOLINT use after move

    REQUIRE(v[0] == 1);
    REQUIRE(v[1] == 42);
    REQUIRE(v[2] == 666);
}

TEST_CASE("static_vector<std::string> move self-assign")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    v = std::move(v); // NOLINT

    REQUIRE(v.size() == 3); // NOLINT use after move

    REQUIRE(v[0] == "1");
    REQUIRE(v[1] == "42");
    REQUIRE(v[2] == "666");
}

TEST_CASE("static_vector<int> move construct")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    static_vector<int, 3> v2(std::move(v));
    REQUIRE(v.size() == 0); // NOLINT use after move
    REQUIRE(v2.size() == 3);

    REQUIRE(v2[0] == 1);
    REQUIRE(v2[1] == 42);
    REQUIRE(v2[2] == 666);
}

TEST_CASE("static_vector<std::string> move construct")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    static_vector<std::string, 3> v2(std::move(v));
    REQUIRE(v.size() == 0); // NOLINT use after move
    REQUIRE(v2.size() == 3);

    REQUIRE(v2[0] == "1");
    REQUIRE(v2[1] == "42");
    REQUIRE(v2[2] == "666");
}

TEST_CASE("static_vector<int> move assign")
{
    static_vector<int, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    static_vector<int, 3> v2;
    v2 = std::move(v);

    REQUIRE(v.size() == 0); // NOLINT use after move
    REQUIRE(v2.size() == 3);

    REQUIRE(v2[0] == 1);
    REQUIRE(v2[1] == 42);
    REQUIRE(v2[2] == 666);
}

TEST_CASE("static_vector<std::string> move assign")
{
    static_vector<std::string, 3> v;

    REQUIRE(v.size() == 0);
    REQUIRE(v.capacity() == 3);

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    static_vector<std::string, 3> v2;
    v2 = std::move(v);
    REQUIRE(v.size() == 0); // NOLINT use after move
    REQUIRE(v2.size() == 3);

    REQUIRE(v2[0] == "1");
    REQUIRE(v2[1] == "42");
    REQUIRE(v2[2] == "666");
}

TEST_CASE("static_vector<int> iterators work")
{
    static_vector<int, 3> v;

    v.emplace_back(1);
    v.emplace_back(42);
    v.emplace_back(666);

    REQUIRE(std::distance(v.begin(), v.end()) == 3);
    REQUIRE(std::ranges::size(v) == 3);

    auto begin = v.begin();
    REQUIRE(*begin++ == 1);
    REQUIRE(*begin++ == 42);
    REQUIRE(*begin++ == 666);
}

TEST_CASE("static_vector<std::string> iterators work")
{
    static_vector<std::string, 3> v;

    v.emplace_back("1");
    v.emplace_back("42");
    v.emplace_back("666");

    REQUIRE(std::distance(v.begin(), v.end()) == 3);
    REQUIRE(std::ranges::size(v) == 3);

    auto begin = v.begin();
    REQUIRE(*begin++ == "1");
    REQUIRE(*begin++ == "42");
    REQUIRE(*begin++ == "666");
}

TEST_CASE("static_vector<unique_ptr<std::string>> calls destructor")
{
    int dtor_count = 0;
    auto destroy = [&](auto *p) { ++dtor_count; delete p; };

    {
        static_vector<std::unique_ptr<std::string, decltype(destroy)>, 2> v;
        v.emplace_back(new std::string("test 1"), destroy);
        v.emplace_back(new std::string("test 2"), destroy);
    }

    REQUIRE(dtor_count == 2);
}

struct move_tester { // NOLINT rule of five
    bool was_moved = false;
    move_tester() = default;
    move_tester(move_tester const &) = default;
    move_tester(move_tester &&other) noexcept
    {
        other.was_moved = true;
    }
};

TEST_CASE("static_vector<> actually moves")
{
    static_vector<move_tester, 3> v;
    v.emplace_back();
    v.emplace_back();
    v.emplace_back();

    auto v2 = std::move(v);

    REQUIRE(v[0].was_moved); // NOLINT use after move
    REQUIRE(v[1].was_moved); // NOLINT use after move
    REQUIRE(v[2].was_moved); // NOLINT use after move
    REQUIRE(!v2[0].was_moved);
    REQUIRE(!v2[1].was_moved);
    REQUIRE(!v2[2].was_moved);
}
