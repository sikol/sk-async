/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <string>
using namespace std::string_literals;
using namespace std::string_view_literals;

#include <catch.hpp>

#include <sk/radix.hxx>

using sk::radix_tree;
using sk::bitstring;

TEST_CASE("bitstring uint8_t") {
    std::array<std::uint8_t, 4> s1, s2;

    bitstring<std::uint8_t> bits(s1);

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    bitstring<std::uint8_t> a(s1), b(s2);

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    bitstring<std::uint8_t> mbs(s1, bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a;
    b <<= 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a;
    b <<= 1;
    REQUIRE(b.str() == "101");

    a = "11010001'10111000'011";
    b = a;
    b <<= 5;
    REQUIRE(b.str() == "00110111000011");

    a = "00000110011011110110111101100110";
    b = a;
    b <<= 15;
    REQUIRE(b.str() == "10110111101100110");

    fmt::print("--here--\n");
    a = "011001100110111101101111";
    b = "011000100110000101110010";
    c = common_prefix(a, b);
    fmt::print("{}\n", c.str());
    REQUIRE(c.str() == "01100");

    a = "01110100011001010110000101101101";
    b = "011";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "011");
}

TEST_CASE("bitstring uint16_t") {
    std::array<std::uint16_t, 2> s1, s2;
    bitstring<std::uint16_t> bits(s1);

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    bitstring<std::uint16_t> a(s1), b(s2);

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    bitstring<std::uint16_t> mbs(s1, bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a;
    b <<= 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a;
    b <<= 1;
    REQUIRE(b.str() == "101");

    a = "11010001'10111000'011";
    b = a;
    b <<= 5;
    REQUIRE(b.str() == "00110111000011");
}

TEST_CASE("bitstring uint64_t") {
    std::array<std::uint64_t, 2> s1, s2;
    bitstring<std::uint64_t> bits(s1);

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    bitstring<std::uint64_t> a(s1), b(s2);

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    bitstring<std::uint64_t> mbs(s1, bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a;
    b <<= 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a;
    b <<= 1;
    REQUIRE(b.str() == "101");

    a = "0000000000000000011111111111111110000110011011110110111101100110";
    b = a;
    b <<= 15;
    REQUIRE(b.str() == "0011111111111111110000110011011110110111101100110");
}

TEST_CASE("radix byte inserts") {
    radix_tree<std::byte, int> trie;

    std::byte b1{0b11110000};
    std::byte b2{0b11111000};

    fmt::print("\n--HERE insert 1 --\n\n");
    trie.insert(std::span(&b1, 1), 42);

    fmt::print("\n--HERE insert 2--\n\n");
    trie.insert(std::span(&b2, 1), 42);

    fmt::print("\n--HERE find 1--\n\n");
    auto r = trie.find(std::span(&b1, 1));
    REQUIRE(r);

    fmt::print("\n--HERE find 2--\n\n");
    r = trie.find(std::span(&b2, 1));
    REQUIRE(r);
}

#if 1
TEST_CASE("radix basic inserts")
{
    std::vector<std::string_view> test_strings{
        "test"sv,
        "testep"sv,
        "tester"sv,
        "testzz"sv,
        "team"sv,
        "tam"sv,
        "foo"sv,
        "bar"sv,
    };

    std::ranges::sort(test_strings);

    do {
        radix_tree<char, std::string> trie;
        // fmt::print("\n\n-- START PERMUTATION --\n\n");

        std::string info;
        for (auto &&s : test_strings)
            info += "->" + std::string(s);

        INFO(info);

        for (auto &&s : test_strings) {
            //fmt::print("inserting [{}]\n", s);
            auto b = trie.insert(s, std::string(s));
            REQUIRE(b);
        }

        for (auto &&s : test_strings) {
            //fmt::print("finding [{}]\n", s);
            auto r = trie.find(s);
            REQUIRE(r);
            REQUIRE(*r == s);
        }

        for (std::size_t i = 0; i < test_strings.size(); ++i) {
            auto b = trie.remove(test_strings[i]);
            REQUIRE(b);

            for (std::size_t j = 0; j < test_strings.size(); ++j) {
                auto r = trie.find(test_strings[j]);
                if (j <= i) {
                    REQUIRE(!r);
                } else {
                    REQUIRE(r);
                    REQUIRE(*r == test_strings[j]);
                }
            }
        }
    } while (std::ranges::next_permutation(test_strings).found);
}
#endif
