/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <string>
using namespace std::string_literals;
using namespace std::string_view_literals;

#include <catch.hpp>

#include <sk/radix.hxx>

using sk::biterator;
using sk::bit_range;
using sk::radix_tree;

TEST_CASE("biterator")
{
    std::byte b{0b10110010};
    biterator bit(std::span(&b, 1)), bend;
    std::vector<bool> bits;
    std::copy(bit, biterator(), std::back_inserter(bits));
    REQUIRE(bits == std::vector<bool>{
                        true, false, true, true, false, false, true, false});

    std::array bytes{
        std::byte{0b10110010},
        std::byte{0b00101101},
        std::byte{0b11100101},
    };

    biterator bit2(bytes);

    bits.clear();
    std::copy(bit2, bend, std::back_inserter(bits));
    REQUIRE(bits == std::vector<bool>{1, 0, 1, 1, 0, 0, 1, 0, //
                                      0, 0, 1, 0, 1, 1, 0, 1, //
                                      1, 1, 1, 0, 0, 1, 0, 1});
}

TEST_CASE("bit_range") {
    std::byte b{0b10110010};
    bit_range r1(std::span(&b, 1));

    std::vector<bool> bits;
    std::ranges::copy(r1, std::back_inserter(bits));
    REQUIRE(bits == std::vector<bool>{
            true, false, true, true, false, false, true, false});

    std::array bytes{
            std::byte{0b10110010},
            std::byte{0b00101101},
            std::byte{0b11100101},
    };

    bit_range r2(bytes);

    bits.clear();
    std::ranges::copy(r2, std::back_inserter(bits));
    REQUIRE(bits == std::vector<bool>{1, 0, 1, 1, 0, 0, 1, 0, //
                                      0, 0, 1, 0, 1, 1, 0, 1, //
                                      1, 1, 1, 0, 0, 1, 0, 1});
}

TEST_CASE("radix byte inserts") {
    radix_tree<std::byte, int> trie;

    std::byte b1{0b11110000};
    std::byte b2{0b11111000};

    fmt::print("\n--HERE insert 1 --\n\n");
    trie.insert(std::span(&b1, 1), 42);

    fmt::print("\n--HERE insert 2--\n\n");
    trie.insert(std::span(&b2, 1), 42);

    fmt::print("\n--HERE find 1--\n\n");
    auto r = trie.find(std::span(&b1, 1));
    REQUIRE(r);

    fmt::print("\n--HERE find 2--\n\n");
    r = trie.find(std::span(&b2, 1));
    REQUIRE(r);
}

#if 1
TEST_CASE("radix basic inserts")
{
    std::vector<std::string_view> test_strings{
        "test"sv,
        "testep"sv,
        "tester"sv,
        "testzz"sv,
        "team"sv,
        "tam"sv,
        "foo"sv,
        //"bar"sv,
    };

    std::ranges::sort(test_strings);

    do {
        radix_tree<char, std::string> trie;
        // fmt::print("\n\n-- START PERMUTATION --\n\n");

        std::string info;
        for (auto &&s : test_strings)
            info += "->" + std::string(s);

        INFO(info);

        for (auto &&s : test_strings) {
            auto b = trie.insert(s, std::string(s));
            REQUIRE(b);
        }

        for (auto &&s : test_strings) {
            auto r = trie.find(s);
            REQUIRE(r);
            REQUIRE(*r == s);
        }

        for (std::size_t i = 0; i < test_strings.size(); ++i) {
            auto b = trie.remove(test_strings[i]);
            REQUIRE(b);

            for (std::size_t j = 0; j < test_strings.size(); ++j) {
                auto r = trie.find(test_strings[j]);
                if (j <= i) {
                    REQUIRE(!r);
                } else {
                    REQUIRE(r);
                    REQUIRE(*r == test_strings[j]);
                }
            }
        }
    } while (std::ranges::next_permutation(test_strings).found);
}
#endif
