/*
 * Copyright (c) 2019, 2020, 2021 SiKol Ltd.
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer,
 * must be included in all copies of the Software, in whole or in part, and
 * all derivative works of the Software, unless such copies or derivative
 * works are solely in the form of machine-executable object code generated by
 * a source language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

#include <string>
using namespace std::string_literals;
using namespace std::string_view_literals;

#include <catch.hpp>

#include <sk/radix.hxx>

using sk::radix_tree;
using sk::bitstring;
using sk::multi_bitstring;

TEST_CASE("multi_bitstring uint8_t") {
    multi_bitstring<4, std::uint8_t> bits;

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    multi_bitstring<4, std::uint8_t> a, b;

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    multi_bitstring<4, std::uint8_t> mbs(bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a << 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a << 1;
    REQUIRE(b.str() == "101");

    a = "11010001'10111000'011";
    b = a << 5;
    REQUIRE(b.str() == "00110111000011");

    a = "00000110011011110110111101100110";
    b = a << 15;
    REQUIRE(b.str() == "10110111101100110");

    a = "011001100110111101101111";
    b = "011000100110000101110010";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "01100");

    a = "01110100011001010110000101101101";
    b = "011";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "011");
}

TEST_CASE("multi_bitstring uint16_t") {
    multi_bitstring<2, std::uint16_t> bits;

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    multi_bitstring<2, std::uint16_t> a, b;

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

#if 0
    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    multi_bitstring<2, std::uint16_t> mbs(bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");
#endif

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a << 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a << 1;
    REQUIRE(b.str() == "101");

    a = "11010001'10111000'011";
    b = a << 5;
    REQUIRE(b.str() == "00110111000011");
}

TEST_CASE("multi_bitstring uint64_t") {
    multi_bitstring<2, std::uint64_t> bits;

    REQUIRE(bits.str() == "");

    bits.append(1);
    REQUIRE(bits.str() == "1");
    bits.append(0);
    REQUIRE(bits.str() == "10");

    bits = "00101100'11010000'01111001";
    REQUIRE(bits.str() == "001011001101000001111001");

    multi_bitstring<2, std::uint64_t> a, b;

    a = "1";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "11");

    a = "1";
    b = "1101";
    a.append(b);
    REQUIRE(a.str() == "11101");

    a = "0101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "01011");

    a = "01010101";
    b = "1";
    a.append(b);
    REQUIRE(a.str() == "010101011");

    a = "111111";
    b = "0000";
    a.append(b);
    REQUIRE(a.str() == "1111110000");

    a = "111111";
    b = "110000000011111111";
    a.append(b);
    REQUIRE(a.str() == "111111110000000011111111");

    a = "110000000011111111";
    b = "111111";
    a.append(b);
    REQUIRE(a.str() == "110000000011111111111111");

    a = "11001100'11001100'11";
    b = "10101010'10101";
    a.append(b);
    REQUIRE(a.str() == "1100110011001100111010101010101");

#if 0
    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    multi_bitstring<2, std::uint16_t> mbs(bytes.data(), bytes.data() + bytes.size());
    REQUIRE(mbs.str() == "011010011110111110010101");
#endif

    a = "101011";
    b = "101010";
    auto c = common_prefix(a, b);
    REQUIRE(c.str() == "10101");

    a = "01100";
    b = "1110001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "");

    a = "11010101'00011010'01001001'0111";
    b = "11010101'00011010'011001";
    c = common_prefix(a, b);
    REQUIRE(c.str() == "110101010001101001");

    a = "11010011'0";
    b = a << 3;
    REQUIRE(b.str() == "100110");

    a = "1101";
    b = a << 1;
    REQUIRE(b.str() == "101");

    a = "0000000000000000011111111111111110000110011011110110111101100110";
    b = a << 15;
    REQUIRE(b.str() == "0011111111111111110000110011011110110111101100110");
}

TEST_CASE("bitstring") {
    bitstring<std::uint64_t> bits;

    bits.append(1);
    REQUIRE(bits.str() == "1");
    REQUIRE(bits.mask() == 0x8000000000000000);

    bits.append(0);
    REQUIRE(bits.str() == "10");
    REQUIRE(bits.mask() == 0xC000000000000000);

    std::vector<bool> v{0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0};
    bits = v;
    REQUIRE(bits.str() == "01010111000");
    REQUIRE(bits[0] == 0);
    REQUIRE(bits[1] == 1);
    REQUIRE(bits[2] == 0);
    REQUIRE(bits[3] == 1);
    REQUIRE(bits[4] == 0);
    REQUIRE(bits[5] == 1);
    REQUIRE(bits[6] == 1);
    REQUIRE(bits[7] == 1);
    REQUIRE(bits[8] == 0);
    REQUIRE(bits[9] == 0);
    REQUIRE(bits[10] == 0);
    REQUIRE(bits.mask() == 0xffe0000000000000);

    REQUIRE((bits << 3).str() == "10111000");

    bitstring<std::uint64_t> a("101100");
    bitstring<std::uint64_t> b("101011");
    REQUIRE(common_prefix(a, b).str() == "101");

    a = "101100";
    b = "001011";
    REQUIRE(common_prefix(a, b).str() == "");
    REQUIRE(a.vec() == std::vector<bool>{1, 0, 1, 1, 0, 0});

    auto c = a + b;
    REQUIRE(c.str() == "101100001011");

    a = "1011000";
    b = "1011000";
    REQUIRE(common_prefix(a, b).str() == "1011000");

    std::array bytes{
        std::byte{0b01101001},
        std::byte{0b11101111},
        std::byte{0b10010101}
    };

    bitstring<std::uint64_t> bs(bytes.data(), bytes.data() + bytes.size());
    REQUIRE(bs.str() == "011010011110111110010101");

    bitstring<std::uint8_t> u8;
    u8 = "11111111";
}

TEST_CASE("radix byte inserts") {
    radix_tree<std::byte, int> trie;

    std::byte b1{0b11110000};
    std::byte b2{0b11111000};

    fmt::print("\n--HERE insert 1 --\n\n");
    trie.insert(std::span(&b1, 1), 42);

    fmt::print("\n--HERE insert 2--\n\n");
    trie.insert(std::span(&b2, 1), 42);

    fmt::print("\n--HERE find 1--\n\n");
    auto r = trie.find(std::span(&b1, 1));
    REQUIRE(r);

    fmt::print("\n--HERE find 2--\n\n");
    r = trie.find(std::span(&b2, 1));
    REQUIRE(r);
}

#if 1
TEST_CASE("radix basic inserts")
{
    std::vector<std::string_view> test_strings{
        "test"sv,
        "testep"sv,
        "tester"sv,
        "testzz"sv,
        "team"sv,
        "tam"sv,
        "foo"sv,
        "bar"sv,
    };

    std::ranges::sort(test_strings);

    do {
        radix_tree<char, std::string> trie;
        // fmt::print("\n\n-- START PERMUTATION --\n\n");

        std::string info;
        for (auto &&s : test_strings)
            info += "->" + std::string(s);

        INFO(info);

        for (auto &&s : test_strings) {
            //fmt::print("inserting [{}]\n", s);
            auto b = trie.insert(s, std::string(s));
            REQUIRE(b);
        }

        for (auto &&s : test_strings) {
            auto r = trie.find(s);
            REQUIRE(r);
            REQUIRE(*r == s);
        }

        for (std::size_t i = 0; i < test_strings.size(); ++i) {
            auto b = trie.remove(test_strings[i]);
            REQUIRE(b);

            for (std::size_t j = 0; j < test_strings.size(); ++j) {
                auto r = trie.find(test_strings[j]);
                if (j <= i) {
                    REQUIRE(!r);
                } else {
                    REQUIRE(r);
                    REQUIRE(*r == test_strings[j]);
                }
            }
        }
    } while (std::ranges::next_permutation(test_strings).found);
}
#endif
